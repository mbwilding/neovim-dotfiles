SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/filetype.lua
Sourced 2 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
                            if vim.g.did_load_filetypes then
                              return
                            end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                if not vim.api.nvim_buf_is_valid(args.buf) then
                                  return
                                end
                                local ft, on_detect = vim.filetype.match({
                                  -- The unexpanded file name is needed here. #27914
                                  -- Neither args.file nor args.match are guaranteed to be unexpanded.
                                  filename = vim.fn.bufname(args.buf),
                                  buf = args.buf,
                                })
                                if not ft then
                                  -- Generic configuration file used as fallback
                                  ft = require('vim.filetype.detect').conf(args.file, args.buf)
                                  if ft then
                                    vim.api.nvim_buf_call(args.buf, function()
                                      vim.api.nvim_cmd({ cmd = 'setf', args = { 'FALLBACK', ft } }, {})
                                    end)
                                  end
                                else
                                  -- on_detect is called before setting the filetype so that it can set any buffer local
                                  -- variables that may be used the filetype's ftplugin
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                            
                                  vim.api.nvim_buf_call(args.buf, function()
                                    vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})
                                  end)
                                end
                              end,
                            })
                            
                            -- These *must* be sourced after the autocommand above is created
                            if not vim.g.did_load_ftdetect then
                              vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.{vim,lua}
                              augroup END
                              ]])
                            end
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end

SCRIPT  /Users/anon/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua
Sourced 1 time
Total time:   0.006239
 Self time:   0.006239

count  total (s)   self (s)
                            vim.filetype.add({
                            	extension = { snippets = "snippets" },
                            })
                            
                            local function silent_map(mode, lhs, rhs, desc)
                            	vim.keymap.set(mode, lhs, rhs, { silent = true, desc = desc or "" })
                            end
                            
                            silent_map("i", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("i", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("i", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("i", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            silent_map("n", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            silent_map("!", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            
                            silent_map("", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            silent_map("!", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            
                            silent_map("s", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("s", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("s", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("s", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            vim.api.nvim_create_user_command("LuaSnipUnlinkCurrent", function()
                            	require("luasnip").unlink_current()
                            end, { force = true })
                            
                            --stylua: ignore
                            vim.api.nvim_create_user_command("LuaSnipListAvailable", function()
                            	(
                            		(
                            			vim.version
                            			and type(vim.version) == "table"
                            			and (
                            				((vim.version().major == 0) and (vim.version().minor >= 9))
                            				or (vim.version().major > 0) )
                            		) and vim.print
                            		  or vim.pretty_print
                            	)(require("luasnip").available())
                            end, { force = true })
                            
                            require("luasnip.config")._setup()
                            
                            -- register these during startup so lazy_load will also load filetypes whose
                            -- events fired only before lazy_load is actually called.
                            -- (BufWinEnter -> lazy_load() wouldn't load any files without these).
                            vim.api.nvim_create_augroup("_luasnip_lazy_load", {})
                            vim.api.nvim_create_autocmd({ "BufWinEnter", "FileType" }, {
                            	callback = function(event)
                            		require("luasnip.loaders").load_lazy_loaded(tonumber(event.buf))
                            	end,
                            	group = "_luasnip_lazy_load",
                            })

SCRIPT  /Users/anon/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004 function! luasnip#expandable()
                            	return luaeval('require("luasnip").expandable()')
                            endfunction
                            
    1              0.000001 function! luasnip#expand_or_jumpable()
                            	return luaeval('require("luasnip").expand_or_jumpable()')
                            endfunction
                            
    1              0.000001 function! luasnip#expand_or_locally_jumpable()
                            	return luaeval('require("luasnip").expand_or_locally_jumpable()')
                            endfunction
                            
    1              0.000001 function! luasnip#locally_jumpable(direction)
                            	return luaeval('require("luasnip").locally_jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000000 function! luasnip#jumpable(direction)
                            	return luaeval('require("luasnip").jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000000 function! luasnip#choice_active()
                            	return luaeval('require("luasnip").choice_active()')
                            endfunction

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
Sourced 1 time
Total time:   0.000958
 Self time:   0.000958

count  total (s)   self (s)
                            if vim.g.loaded_cmp then
                              return
                            end
                            vim.g.loaded_cmp = true
                            
                            if not vim.api.nvim_create_autocmd then
                              return print('[nvim-cmp] Your nvim does not has `nvim_create_autocmd` function. Please update to latest nvim.')
                            end
                            
                            local api = require('cmp.utils.api')
                            local types = require('cmp.types')
                            local highlight = require('cmp.utils.highlight')
                            local autocmd = require('cmp.utils.autocmd')
                            
                            vim.api.nvim_set_hl(0, 'CmpItemAbbr', { link = 'CmpItemAbbrDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrDeprecated', { link = 'CmpItemAbbrDeprecatedDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatch', { link = 'CmpItemAbbrMatchDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatchFuzzy', { link = 'CmpItemAbbrMatchFuzzyDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemKind', { link = 'CmpItemKindDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemMenu', { link = 'CmpItemMenuDefault', default = true })
                            for kind in pairs(types.lsp.CompletionItemKind) do
                              if type(kind) == 'string' then
                                local name = ('CmpItemKind%s'):format(kind)
                                vim.api.nvim_set_hl(0, name, { link = ('%sDefault'):format(name), default = true })
                              end
                            end
                            
                            autocmd.subscribe({ 'ColorScheme', 'UIEnter' }, function()
                              highlight.inherit('CmpItemAbbrDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrDeprecatedDefault', 'Comment', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchFuzzyDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemKindDefault', 'Special', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemMenuDefault', 'Pmenu', { bg = 'NONE', default = false })
                              for name in pairs(types.lsp.CompletionItemKind) do
                                if type(name) == 'string' then
                                  vim.api.nvim_set_hl(0, ('CmpItemKind%sDefault'):format(name), { link = 'CmpItemKind', default = false })
                                end
                              end
                            end)
                            autocmd.emit('ColorScheme')
                            
                            if vim.on_key then
                              local control_c_termcode = vim.api.nvim_replace_termcodes('<C-c>', true, true, true)
                              vim.on_key(function(keys)
                                if keys == control_c_termcode then
                                  vim.schedule(function()
                                    if not api.is_suitable_mode() then
                                      autocmd.emit('InsertLeave')
                                    end
                                  end)
                                end
                              end, vim.api.nvim_create_namespace('cmp.plugin'))
                            end
                            
                            
                            vim.api.nvim_create_user_command('CmpStatus', function()
                              require('cmp').status()
                            end, { desc = 'Check status of cmp sources' })
                            
                            vim.cmd([[doautocmd <nomodeline> User CmpReady]])

SCRIPT  /Users/anon/.local/share/nvim/lazy/gronk.nvim/colors/gronk-wilding.lua
Sourced 1 time
Total time:   0.004043
 Self time:   0.004043

count  total (s)   self (s)
                            require("gronk").load({ style = "wilding" })

SCRIPT  /Users/anon/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                            
                            " Create command for running busted
    1              0.000005 command! -nargs=1 -complete=file PlenaryBustedFile
                                  \ lua require('plenary.test_harness').test_file([[<args>]])
                            
    1              0.000002 command! -nargs=+ -complete=file PlenaryBustedDirectory
                                  \ lua require('plenary.test_harness').test_directory_command([[<args>]])
                            
    1              0.000004 nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_devicons') | finish | endif
                            
    1              0.000002 let s:save_cpo = &cpo
    1              0.000002 set cpo&vim
                            
                            " TODO change so its easier to get
    1              0.000001 let g:nvim_web_devicons = 1
                            
    1              0.000001 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
    1              0.000001 let g:loaded_devicons = 1

SCRIPT  /Users/anon/.local/share/nvim/lazy/vim-rhubarb/plugin/rhubarb.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " rhubarb.vim - fugitive.vim extension for GitHub
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000002 if exists("g:loaded_rhubarb") || v:version < 700 || &cp
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_rhubarb = 1
                            
    1              0.000001 if !exists('g:dispatch_compilers')
    1              0.000001   let g:dispatch_compilers = {}
    1              0.000000 endif
    1              0.000001 let g:dispatch_compilers['hub'] = 'git'
                            
    1              0.000001 function! s:SetUpMessage(filename) abort
                              if &omnifunc !~# '^\%(syntaxcomplete#Complete\)\=$' ||
                                    \ a:filename !~# '\.git[\/].*MSG$' ||
                                    \ !exists('*FugitiveFind')
                                return
                              endif
                              let dir = exists('*FugitiveConfigGetRegexp') ? FugitiveGitDir() : FugitiveExtractGitDir(a:filename)
                              if empty(dir)
                                return
                              endif
                              let config_file = FugitiveFind('.git/config', dir)
                              let config = filereadable(config_file) ? readfile(config_file) : []
                              if !empty(filter(config,
                                    \ '!empty(rhubarb#HomepageForUrl(matchstr(v:val, ''^\s*url\s*=\s*"\=\zs[^[:space:]"]*'')))'))
                                setlocal omnifunc=rhubarb#Complete
                              endif
                            endfunction
                            
    1              0.000000 augroup rhubarb
    1              0.000002   autocmd!
    1              0.000001   if exists('+omnifunc')
    1              0.000002     autocmd FileType gitcommit call s:SetUpMessage(expand('<afile>:p'))
    1              0.000000   endif
    1              0.000002   autocmd BufEnter *
                                    \ if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'rhubarb#omnifunc' |
                                    \    setlocal nolist linebreak filetype=markdown |
                                    \ endif
    1              0.000005   autocmd BufNewFile,BufRead *.git/{PULLREQ_EDIT,ISSUE_EDIT,RELEASE_EDIT}MSG
                                    \ if &ft ==# '' || &ft ==# 'conf' |
                                    \   set ft=gitcommit |
                                    \ endif
    1              0.000000 augroup END
                            
    1              0.000001 if !exists('g:fugitive_browse_handlers')
    1              0.000001   let g:fugitive_browse_handlers = []
    1              0.000000 endif
                            
    1              0.000002 if index(g:fugitive_browse_handlers, function('rhubarb#FugitiveUrl')) < 0
    1              0.000002   call insert(g:fugitive_browse_handlers, function('rhubarb#FugitiveUrl'))
    1              0.000001 endif

SCRIPT  /Users/anon/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim
Sourced 1 time
Total time:   0.000400
 Self time:   0.000366

count  total (s)   self (s)
                            " fugitive.vim - A Git wrapper so awesome, it should be illegal
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      3.7
                            " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
                            
    1              0.000001 if exists('g:loaded_fugitive')
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_fugitive = 1
                            
    1              0.000001 let s:bad_git_dir = '/$\|^fugitive:'
                            
                            " FugitiveGitDir() returns the detected Git dir for the given buffer number,
                            " or the current buffer if no argument is passed.  This will be an empty
                            " string if no Git dir was found.  Use !empty(FugitiveGitDir()) to check if
                            " Fugitive is active in the current buffer.  Do not rely on this for direct
                            " filesystem access; use FugitiveFind('.git/whatever') instead.
    1              0.000001 function! FugitiveGitDir(...) abort
                              if v:version < 704
                                return ''
                              elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
                                if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
                                let dir = get(b:, 'git_dir', '')
                                if empty(dir) && (empty(bufname('')) && &filetype !=# 'netrw' || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(bufnr(''))
                                  return b:git_dir
                                endif
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(a:1)
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                              else
                                return ''
                              endif
                            endfunction
                            
                            " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
                            " the work tree.  This may be useful to get a cleaner path for inclusion in
                            " the statusline, for example.  Note that the file and its parent directories
                            " are not guaranteed to exist.
                            "
                            " This is intended as an abstract API to be used on any "virtual" path.  For a
                            " buffer named foo://bar, check for a function named FooReal(), and if it
                            " exists, call FooReal("foo://bar").
    1              0.000000 function! FugitiveReal(...) abort
                              let file = a:0 ? a:1 : @%
                              if type(file) ==# type({})
                                let dir = FugitiveGitDir(file)
                                let tree = s:Tree(dir)
                                return s:VimSlash(empty(tree) ? dir : tree)
                              elseif file =~# '^\a\a\+:' || a:0 > 1
                                return call('fugitive#Real', [file] + a:000[1:-1])
                              elseif file =~# '^/\|^\a:\|^$'
                                return file
                              else
                                return fnamemodify(file, ':p' . (file =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                            endfunction
                            
                            " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
                            " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
                            " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
                            " dir (".git/config"), or the work tree (":(top)Makefile").
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000000 function! FugitiveFind(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type(0))
                                return call('fugitive#Find', a:000[1:-1] + [FugitiveGitDir(a:1)])
                              else
                                return fugitive#Find(a:0 ? a:1 : bufnr(''), FugitiveGitDir(a:0 > 1 ? a:2 : -1))
                              endif
                            endfunction
                            
                            " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
                            " containing an object name ("commit:file") and the Git dir.  It's effectively
                            " the inverse of FugitiveFind().
    1              0.000000 function! FugitiveParse(...) abort
                              let path = s:Slash(a:0 ? a:1 : @%)
                              if path !~# '^fugitive://'
                                return ['', '']
                              endif
                              let [rev, dir] = fugitive#Parse(path)
                              if !empty(dir)
                                return [rev, dir]
                              endif
                              throw 'fugitive: invalid Fugitive URL ' . path
                            endfunction
                            
                            " FugitiveGitVersion() queries the version of Git in use.  Pass up to 3
                            " arguments to return a Boolean of whether a certain minimum version is
                            " available (FugitiveGitVersion(2,3,4) checks for 2.3.4 or higher) or no
                            " arguments to get a raw string.
    1              0.000000 function! FugitiveGitVersion(...) abort
                              return call('fugitive#GitVersion', a:000)
                            endfunction
                            
                            " FugitiveResult() returns an object encapsulating the result of the most
                            " recent :Git command.  Will be empty if no result is available.  During a
                            " User FugitiveChanged event, this is guaranteed to correspond to the :Git
                            " command that triggered the event, or be empty if :Git was not the trigger.
                            " Pass in the name of a temp buffer to get the result object for that command
                            " instead.  Contains the following keys:
                            "
                            " * "args": List of command arguments, starting with the subcommand.  Will be
                            "   empty for usages like :Git --help.
                            " * "git_dir": Git dir of the relevant repository.
                            " * "exit_status": The integer exit code of the process.
                            " * "flags": Flags passed directly to Git, like -c and --help.
                            " * "file": Path to file containing command output.  Not guaranteed to exist,
                            "   so verify with filereadable() before trying to access it.
    1              0.000000 function! FugitiveResult(...) abort
                              return call('fugitive#Result', a:000)
                            endfunction
                            
                            " FugitiveExecute() runs Git with a list of arguments and returns a dictionary
                            " with the following keys:
                            "
                            " * "exit_status": The integer exit code of the process.
                            " * "stdout": The stdout produced by the process, as a list of lines.
                            " * "stderr": The stdout produced by the process, as a list of lines.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
                            "
                            " An optional final argument is a callback Funcref, for asynchronous
                            " execution.
    1              0.000000 function! FugitiveExecute(args, ...) abort
                              return call('fugitive#Execute', [a:args] + a:000)
                            endfunction
                            
                            " FugitiveShellCommand() turns an array of arguments into a Git command string
                            " which can be executed with functions like system() and commands like :!.
                            " Integer arguments will be treated as buffer numbers, and the appropriate
                            " relative path inserted in their place.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000000 function! FugitiveShellCommand(...) abort
                              return call('fugitive#ShellCommand', a:000)
                            endfunction
                            
                            " FugitiveConfig() get returns an opaque structure that can be passed to other
                            " FugitiveConfig functions in lieu of a Git directory.  This can be faster
                            " when performing multiple config queries.  Do not rely on the internal
                            " structure of the return value as it is not guaranteed.  If you want a full
                            " dictionary of every config value, use FugitiveConfigGetRegexp('.*').
                            "
                            " An optional argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.  Pass a blank
                            " string to limit to the global config.
    1              0.000000 function! FugitiveConfig(...) abort
                              return call('fugitive#Config', a:000)
                            endfunction
                            
                            " FugitiveConfigGet() retrieves a Git configuration value.  An optional second
                            " argument can be either the object returned by FugitiveConfig(), or a Git
                            " dir or buffer number to be passed along to FugitiveConfig().
    1              0.000000 function! FugitiveConfigGet(name, ...) abort
                              return get(call('FugitiveConfigGetAll', [a:name] + (a:0 ? [a:1] : [])), -1, get(a:, 2, ''))
                            endfunction
                            
                            " FugitiveConfigGetAll() is like FugitiveConfigGet() but returns a list of
                            " all values.
    1              0.000000 function! FugitiveConfigGetAll(name, ...) abort
                              return call('fugitive#ConfigGetAll', [a:name] + a:000)
                            endfunction
                            
                            " FugitiveConfigGetRegexp() retrieves a dictionary of all configuration values
                            " with a key matching the given pattern.  Like git config --get-regexp, but
                            " using a Vim regexp.  Second argument has same semantics as
                            " FugitiveConfigGet().
    1              0.000000 function! FugitiveConfigGetRegexp(pattern, ...) abort
                              return call('fugitive#ConfigGetRegexp', [a:pattern] + a:000)
                            endfunction
                            
                            " FugitiveRemoteUrl() retrieves the remote URL for the given remote name,
                            " defaulting to the current branch's remote or "origin" if no argument is
                            " given.  Similar to `git remote get-url`, but also attempts to resolve HTTP
                            " redirects and SSH host aliases.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000000 function! FugitiveRemoteUrl(...) abort
                              return call('fugitive#RemoteUrl', a:000)
                            endfunction
                            
                            " FugitiveRemote() returns a data structure parsed from the remote URL.
                            " For example, for remote URL "https://me@example.com:1234/repo.git", the
                            " returned dictionary will contain the following:
                            "
                            " * "scheme": "https"
                            " * "authority": "user@example.com:1234"
                            " * "path": "/repo.git" (for SSH URLs this may be a relative path)
                            " * "pathname": "/repo.git" (always coerced to absolute path)
                            " * "host": "example.com:1234"
                            " * "hostname": "example.com"
                            " * "port": "1234"
                            " * "user": "me"
                            " * "path": "/repo.git"
                            " * "url": "https://me@example.com:1234/repo.git"
    1              0.000000 function! FugitiveRemote(...) abort
                              return call('fugitive#Remote', a:000)
                            endfunction
                            
                            " FugitiveDidChange() triggers a FugitiveChanged event and reloads the summary
                            " buffer for the current or given buffer number's repository.  You can also
                            " give the result of a FugitiveExecute() and that context will be made
                            " available inside the FugitiveChanged() event.
                            "
                            " Passing the special argument 0 (the number zero) softly expires summary
                            " buffers for all repositories.  This can be used after a call to system()
                            " with unclear implications.
    1              0.000000 function! FugitiveDidChange(...) abort
                              return call('fugitive#DidChange', a:000)
                            endfunction
                            
                            " FugitiveHead() retrieves the name of the current branch. If the current HEAD
                            " is detached, FugitiveHead() will return the empty string, unless the
                            " optional argument is given, in which case the hash of the current commit
                            " will be truncated to the given number of characters.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000000 function! FugitiveHead(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
                              elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
                              else
                                let dir = FugitiveGitDir()
                                let arg = get(a:, 1, 0)
                              endif
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#Head(arg, dir)
                            endfunction
                            
    1              0.000000 function! FugitivePath(...) abort
                              if a:0 > 2 && type(a:1) ==# type({})
                                return fugitive#Path(a:2, a:3, FugitiveGitDir(a:1))
                              elseif a:0 && type(a:1) ==# type({})
                                return FugitiveReal(a:0 > 1 ? a:2 : @%)
                              elseif a:0 > 1
                                return fugitive#Path(a:1, a:2, FugitiveGitDir(a:0 > 2 ? a:3 : -1))
                              else
                                return FugitiveReal(a:0 ? a:1 : @%)
                              endif
                            endfunction
                            
    1              0.000000 function! FugitiveStatusline(...) abort
                              if empty(FugitiveGitDir(bufnr('')))
                                return ''
                              endif
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000001 let s:resolved_git_dirs = {}
    1              0.000000 function! FugitiveActualDir(...) abort
                              let dir = call('FugitiveGitDir', a:000)
                              if empty(dir)
                                return ''
                              endif
                              if !has_key(s:resolved_git_dirs, dir)
                                let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
                              endif
                              return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]
                            endfunction
                            
    1              0.000000 let s:commondirs = {}
    1              0.000000 function! FugitiveCommonDir(...) abort
                              let dir = call('FugitiveActualDir', a:000)
                              if empty(dir)
                                return ''
                              endif
                              if has_key(s:commondirs, dir)
                                return s:commondirs[dir]
                              endif
                              if getfsize(dir . '/HEAD') >= 10
                                let cdir = get(s:ReadFile(dir . '/commondir', 1), 0, '')
                                if cdir =~# '^/\|^\a:/'
                                  let s:commondirs[dir] = s:Slash(FugitiveVimPath(cdir))
                                elseif len(cdir)
                                  let s:commondirs[dir] = simplify(dir . '/' . cdir)
                                else
                                  let s:commondirs[dir] = dir
                                endif
                              else
                                let s:commondirs[dir] = dir
                              endif
                              return s:commondirs[dir]
                            endfunction
                            
    1              0.000000 function! FugitiveWorkTree(...) abort
                              let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
                              if tree isnot# 0 || a:0 > 1
                                return tree
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000000 function! FugitiveIsGitDir(...) abort
                              if !a:0 || type(a:1) !=# type('')
                                return !empty(call('FugitiveGitDir', a:000))
                              endif
                              let path = substitute(a:1, '[\/]$', '', '') . '/'
                              return len(path) && getfsize(path.'HEAD') > 10 && (
                                    \ isdirectory(path.'objects') && isdirectory(path.'refs') ||
                                    \ getftype(path.'commondir') ==# 'file')
                            endfunction
                            
    1              0.000001 function! s:ReadFile(path, line_count) abort
                              if v:version < 800 && !filereadable(a:path)
                                return []
                              endif
                              try
                                return readfile(a:path, 'b', a:line_count)
                              catch
                                return []
                              endtry
                            endfunction
                            
    1              0.000001 let s:worktree_for_dir = {}
    1              0.000001 let s:dir_for_worktree = {}
    1              0.000000 function! s:Tree(path) abort
                              if a:path =~# '/\.git$'
                                return len(a:path) ==# 5 ? '/' : a:path[0:-6]
                              elseif a:path ==# ''
                                return ''
                              endif
                              let dir = FugitiveActualDir(a:path)
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let ext_wtc_pat = 'v:val =~# "^\\s*worktreeConfig *= *\\%(true\\|yes\\|on\\|1\\) *$"'
                                let config = s:ReadFile(dir . '/config', 50)
                                if len(config)
                                  let ext_wtc_config = filter(copy(config), ext_wtc_pat)
                                  if len(ext_wtc_config) == 1 && filereadable(dir . '/config.worktree')
                                     let config += s:ReadFile(dir . '/config.worktree', 50)
                                  endif
                                else
                                  let worktree = fnamemodify(FugitiveVimPath(get(s:ReadFile(dir . '/gitdir', 1), '0', '')), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                  if len(filter(s:ReadFile(FugitiveCommonDir(dir) . '/config', 50), ext_wtc_pat))
                                    let config = s:ReadFile(dir . '/config.worktree', 50)
                                  endif
                                endif
                                if len(config)
                                  let wt_config = filter(copy(config), 'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config)
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  elseif !exists('worktree')
                                    call filter(config,'v:val =~# "^\\s*bare *= *true *$"')
                                    if empty(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif
                            endfunction
                            
    1              0.000000 function! s:CeilingDirectories() abort
                              if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, s:Slash(resolve(dir)))
                                  else
                                    call add(s:ceiling_directories, s:Slash(dir))
                                  endif
                                endfor
                              endif
                              return s:ceiling_directories + get(g:, 'ceiling_directories', [s:Slash(fnamemodify(expand('~'), ':h'))])
                            endfunction
                            
    1              0.000000 function! s:ResolveGitDir(git_dir) abort
                              let type = getftype(a:git_dir)
                              if type ==# 'dir' && FugitiveIsGitDir(a:git_dir)
                                return a:git_dir
                              elseif type ==# 'link' && FugitiveIsGitDir(a:git_dir)
                                return resolve(a:git_dir)
                              elseif type !=# ''
                                let line = get(s:ReadFile(a:git_dir, 1), 0, '')
                                let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                if file_dir !~# '^/\|^\a:\|^$' && a:git_dir =~# '/\.git$' && FugitiveIsGitDir(a:git_dir[0:-5] . file_dir)
                                  return simplify(a:git_dir[0:-5] . file_dir)
                                elseif file_dir =~# '^/\|^\a:' && FugitiveIsGitDir(file_dir)
                                  return file_dir
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000000 function! FugitiveExtractGitDir(path) abort
                              if type(a:path) ==# type({})
                                return get(a:path, 'fugitive_dir', get(a:path, 'git_dir', ''))
                              elseif type(a:path) == type(0)
                                let path = s:Slash(a:path > 0 ? bufname(a:path) : bufname(''))
                                if getbufvar(a:path, '&filetype') ==# 'netrw'
                                  let path = s:Slash(getbufvar(a:path, 'netrw_curdir', path))
                                endif
                              else
                                let path = s:Slash(a:path)
                              endif
                              if path =~# '^fugitive://'
                                return fugitive#Parse(path)[1]
                              elseif empty(path)
                                return ''
                              endif
                              let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && exists('*' . pre . 'Real')
                                let path = {pre}Real(path)
                              endif
                              let root = s:Slash(fnamemodify(path, ':p:h'))
                              let previous = ""
                              let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
                              call s:Tree(env_git_dir)
                              let ceiling_directories = s:CeilingDirectories()
                              while root !=# previous && root !~# '^$\|^//[^/]*$'
                                if index(ceiling_directories, root) >= 0
                                  break
                                endif
                                if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
                                let dir = substitute(root, '[\/]$', '', '') . '/.git'
                                let resolved = s:ResolveGitDir(dir)
                                if !empty(resolved)
                                  let s:resolved_git_dirs[dir] = resolved
                                  return dir is# resolved || s:Tree(resolved) is# 0 ? dir : resolved
                                elseif FugitiveIsGitDir(root)
                                  let s:resolved_git_dirs[root] = root
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000000 function! FugitiveDetect(...) abort
                              if v:version < 704
                                return ''
                              endif
                              if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
                              endif
                              if !exists('b:git_dir')
                                let b:git_dir = FugitiveExtractGitDir(a:0 ? a:1 : bufnr(''))
                              endif
                              return ''
                            endfunction
                            
    1              0.000000 function! FugitiveGitPath(path) abort
                              return s:Slash(a:path)
                            endfunction
                            
    1              0.000001 if exists('+shellslash')
                            
                              function! s:Slash(path) abort
                                return tr(a:path, '\', '/')
                              endfunction
                            
                              function! s:VimSlash(path) abort
                                return tr(a:path, '\/', &shellslash ? '//' : '\\')
                              endfunction
                            
                              function FugitiveVimPath(path) abort
                                return tr(a:path, '\/', &shellslash ? '//' : '\\')
                              endfunction
                            
    1              0.000000 else
                            
    1              0.000000   function! s:Slash(path) abort
                                return a:path
                              endfunction
                            
    1              0.000000   function! s:VimSlash(path) abort
                                return a:path
                              endfunction
                            
    1              0.000002   if has('win32unix') && filereadable('/git-bash.exe')
                                function! FugitiveVimPath(path) abort
                                  return substitute(a:path, '^\(\a\):', '/\l\1', '')
                                endfunction
    1              0.000000   else
    1              0.000000     function! FugitiveVimPath(path) abort
                                  return a:path
                                endfunction
    1              0.000000   endif
                            
    1              0.000000 endif
                            
    1              0.000000 function! s:ProjectionistDetect() abort
                              let file = s:Slash(get(g:, 'projectionist_file', ''))
                              let dir = FugitiveExtractGitDir(file)
                              let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
                              if empty(base)
                                let base = s:Tree(dir)
                              endif
                              if !empty(base)
                                if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
                                let file = FugitiveFind('.git/info/projections.json', dir)
                                if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 let s:addr_other = has('patch-8.1.560') || has('nvim-0.5.0') ? '-addr=other' : ''
    1              0.000001 let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
    1              0.000001 let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
                            
    1              0.000001 if exists(':G') != 2
    1              0.000004   command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
    1              0.000000 endif
    1              0.000003 command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
                            
    1              0.000002 if exists(':Gstatus') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gstatus is deprecated in favor of :Git (with no arguments)"|echohl NONE'
    1              0.000000 endif
                            
    9              0.000004 for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
    8              0.000010   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
                                exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd)
                                      \ 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|'
                                      \ 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
    8              0.000001   endif
    9              0.000002 endfor
    1              0.000000 unlet s:cmd
                            
    1              0.000002 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
    1              0.000002 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
                            
    1              0.000006 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000004 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000004 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000004 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
    1              0.000004 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
                            
    1              0.000003 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)'
    1              0.000005 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)'
    1              0.000005 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000001 if exists(':Gr') != 2
    1              0.000004   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000000 endif
    1              0.000004 exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000003 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)'
                            
    1              0.000004 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000004 exe 'command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000003 exe 'command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000001 if exists(':Gremove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=0 Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gremove is deprecated in favor of :GRemove"|echohl NONE'
    1              0.000001 elseif exists(':Gremove') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000002   exe 'command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"'
    1              0.000000 endif
    1              0.000001 if exists(':Gdelete') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=0 Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gdelete is deprecated in favor of :GDelete"|echohl NONE'
    1              0.000001 elseif exists(':Gdelete') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000002   exe 'command! -bar -bang -nargs=0 Gdelete echoerr ":Gdelete has been removed in favor of :GDelete"'
    1              0.000000 endif
    1              0.000001 if exists(':Gmove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gmove is deprecated in favor of :GMove"|echohl NONE'
    1              0.000001 elseif exists(':Gmove') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000003   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove'
                                    \ 'echoerr ":Gmove has been removed in favor of :GMove"'
    1              0.000000 endif
    1              0.000001 if exists(':Grename') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Grename is deprecated in favor of :GRename"|echohl NONE'
    1              0.000001 elseif exists(':Grename') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000003   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename'
                                    \ 'echoerr ":Grename has been removed in favor of :GRename"'
    1              0.000000 endif
                            
    1              0.000004 exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000001 if exists(':Gbrowse') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|if <bang>1|redraw!|endif|echohl WarningMSG|echomsg ":Gbrowse is deprecated in favor of :GBrowse"|echohl NONE'
    1              0.000001 elseif exists(':Gbrowse') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000003   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse'
                                    \ 'echoerr ":Gbrowse has been removed in favor of :GBrowse"'
    1              0.000000 endif
                            
    1              0.000000 if v:version < 704
                              finish
    1              0.000000 endif
                            
    1              0.000010 let g:io_fugitive = {
                                  \ 'simplify': function('fugitive#simplify'),
                                  \ 'resolve': function('fugitive#resolve'),
                                  \ 'getftime': function('fugitive#getftime'),
                                  \ 'getfsize': function('fugitive#getfsize'),
                                  \ 'getftype': function('fugitive#getftype'),
                                  \ 'filereadable': function('fugitive#filereadable'),
                                  \ 'filewritable': function('fugitive#filewritable'),
                                  \ 'isdirectory': function('fugitive#isdirectory'),
                                  \ 'getfperm': function('fugitive#getfperm'),
                                  \ 'setfperm': function('fugitive#setfperm'),
                                  \ 'readfile': function('fugitive#readfile'),
                                  \ 'writefile': function('fugitive#writefile'),
                                  \ 'glob': function('fugitive#glob'),
                                  \ 'delete': function('fugitive#delete'),
                                  \ 'Real': function('FugitiveReal')}
                            
    1              0.000000 augroup fugitive
    1              0.000001   autocmd!
                            
    1              0.000002   autocmd BufNewFile,BufReadPost *
                                    \ if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |
                                    \   unlet b:git_dir |
                                    \ endif
    1              0.000002   autocmd FileType           netrw
                                    \ if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |
                                    \   unlet b:git_dir |
                                    \ endif
    1              0.000001   autocmd BufFilePost            *  unlet! b:git_dir
                            
    1              0.000001   autocmd FileType git
                                    \ call fugitive#MapCfile()
    1              0.000002   autocmd FileType gitcommit
                                    \ call fugitive#MapCfile('fugitive#MessageCfile()')
    1              0.000002   autocmd FileType git,gitcommit
                                    \ if &foldtext ==# 'foldtext()' |
                                    \    setlocal foldtext=fugitive#Foldtext() |
                                    \ endif
    1              0.000001   autocmd FileType fugitive
                                    \ call fugitive#MapCfile('fugitive#PorcelainCfile()')
    1              0.000003   autocmd FileType gitrebase
                                    \ let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' |
                                    \ if &l:includeexpr !~# 'Fugitive' |
                                    \   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' && len(FugitiveGitDir()) ? FugitiveFind(v:fname) : ' .
                                    \     (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') |
                                    \ endif |
                                    \ let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
                            
    1              0.000004   autocmd BufReadCmd index{,.lock} nested
                                    \ if FugitiveIsGitDir(expand('<amatch>:p:h')) |
                                    \   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |
                                    \   exe fugitive#BufReadStatus(v:cmdbang) |
                                    \   echohl WarningMSG |
                                    \   echo "fugitive: Direct editing of .git/" . expand('%:t') . " is deprecated" |
                                    \   echohl NONE |
                                    \ elseif filereadable(expand('<amatch>')) |
                                    \   silent doautocmd BufReadPre |
                                    \   keepalt noautocmd read <amatch> |
                                    \   silent 1delete_ |
                                    \   silent doautocmd BufReadPost |
                                    \ else |
                                    \   silent doautocmd BufNewFile |
                                    \ endif
                            
    1              0.000002   autocmd BufReadCmd   fugitive://*          nested exe fugitive#BufReadCmd() |
                                    \ if &path =~# '^\.\%(,\|$\)' |
                                    \   let &l:path = substitute(&path, '^\.,\=', '', '') |
                                    \ endif
    1              0.000002   autocmd BufWriteCmd  fugitive://*          nested exe fugitive#BufWriteCmd()
    1              0.000001   autocmd FileReadCmd  fugitive://*          nested exe fugitive#FileReadCmd()
    1              0.000001   autocmd FileWriteCmd fugitive://*          nested exe fugitive#FileWriteCmd()
    1              0.000001   if exists('##SourceCmd')
    1              0.000001     autocmd SourceCmd     fugitive://*       nested exe fugitive#SourceCmd()
    1              0.000000   endif
                            
    1              0.000001   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
                            
    1              0.000002   autocmd User ProjectionistDetect call s:ProjectionistDetect()
    1              0.000000 augroup END
                            
    1              0.000004 nmap <script><silent> <Plug>fugitive:y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
    1              0.000001 nmap <script> <Plug>fugitive: <Nop>
                            
    1              0.000001 if get(g:, 'fugitive_no_maps')
                              finish
    1              0.000000 endif
                            
    1              0.000001 function! s:Map(mode, lhs, rhs, flags) abort
                              let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
                              let head = a:lhs
                              let tail = ''
                              let keys = get(g:, a:mode.'remap', {})
                              if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                              endif
                              if empty(mapcheck(head.tail, a:mode))
                                exe a:mode.'map' flags head.tail a:rhs
                              endif
                            endfunction
                            
    1   0.000023   0.000004 call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
    1   0.000017   0.000003 call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

SCRIPT  /Users/anon/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim
Sourced 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002 autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame

SCRIPT  /Users/anon/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua
Sourced 1 time
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
                            if 1 ~= vim.fn.has "nvim-0.9.0" then
                              vim.api.nvim_err_writeln "Telescope.nvim requires at least nvim-0.9.0. See `:h telescope.changelog-2499`"
                              return
                            end
                            
                            if vim.g.loaded_telescope == 1 then
                              return
                            end
                            vim.g.loaded_telescope = 1
                            
                            local highlights = {
                              -- Sets the highlight for selected items within the picker.
                              TelescopeSelection = { default = true, link = "Visual" },
                              TelescopeSelectionCaret = { default = true, link = "TelescopeSelection" },
                              TelescopeMultiSelection = { default = true, link = "Type" },
                              TelescopeMultiIcon = { default = true, link = "Identifier" },
                            
                              -- "Normal" in the floating windows created by telescope.
                              TelescopeNormal = { default = true, link = "Normal" },
                              TelescopePreviewNormal = { default = true, link = "TelescopeNormal" },
                              TelescopePromptNormal = { default = true, link = "TelescopeNormal" },
                              TelescopeResultsNormal = { default = true, link = "TelescopeNormal" },
                            
                              -- Border highlight groups.
                              --   Use TelescopeBorder to override the default.
                              --   Otherwise set them specifically
                              TelescopeBorder = { default = true, link = "TelescopeNormal" },
                              TelescopePromptBorder = { default = true, link = "TelescopeBorder" },
                              TelescopeResultsBorder = { default = true, link = "TelescopeBorder" },
                              TelescopePreviewBorder = { default = true, link = "TelescopeBorder" },
                            
                              -- Title highlight groups.
                              --   Use TelescopeTitle to override the default.
                              --   Otherwise set them specifically
                              TelescopeTitle = { default = true, link = "TelescopeBorder" },
                              TelescopePromptTitle = { default = true, link = "TelescopeTitle" },
                              TelescopeResultsTitle = { default = true, link = "TelescopeTitle" },
                              TelescopePreviewTitle = { default = true, link = "TelescopeTitle" },
                            
                              TelescopePromptCounter = { default = true, link = "NonText" },
                            
                              -- Used for highlighting characters that you match.
                              TelescopeMatching = { default = true, link = "Special" },
                            
                              -- Used for the prompt prefix
                              TelescopePromptPrefix = { default = true, link = "Identifier" },
                            
                              -- Used for highlighting the matched line inside Previewer. Works only for (vim_buffer_ previewer)
                              TelescopePreviewLine = { default = true, link = "Visual" },
                              TelescopePreviewMatch = { default = true, link = "Search" },
                            
                              TelescopePreviewPipe = { default = true, link = "Constant" },
                              TelescopePreviewCharDev = { default = true, link = "Constant" },
                              TelescopePreviewDirectory = { default = true, link = "Directory" },
                              TelescopePreviewBlock = { default = true, link = "Constant" },
                              TelescopePreviewLink = { default = true, link = "Special" },
                              TelescopePreviewSocket = { default = true, link = "Statement" },
                              TelescopePreviewRead = { default = true, link = "Constant" },
                              TelescopePreviewWrite = { default = true, link = "Statement" },
                              TelescopePreviewExecute = { default = true, link = "String" },
                              TelescopePreviewHyphen = { default = true, link = "NonText" },
                              TelescopePreviewSticky = { default = true, link = "Keyword" },
                              TelescopePreviewSize = { default = true, link = "String" },
                              TelescopePreviewUser = { default = true, link = "Constant" },
                              TelescopePreviewGroup = { default = true, link = "Constant" },
                              TelescopePreviewDate = { default = true, link = "Directory" },
                              TelescopePreviewMessage = { default = true, link = "TelescopePreviewNormal" },
                              TelescopePreviewMessageFillchar = { default = true, link = "TelescopePreviewMessage" },
                            
                              -- Used for Picker specific Results highlighting
                              TelescopeResultsClass = { default = true, link = "Function" },
                              TelescopeResultsConstant = { default = true, link = "Constant" },
                              TelescopeResultsField = { default = true, link = "Function" },
                              TelescopeResultsFunction = { default = true, link = "Function" },
                              TelescopeResultsMethod = { default = true, link = "Method" },
                              TelescopeResultsOperator = { default = true, link = "Operator" },
                              TelescopeResultsStruct = { default = true, link = "Struct" },
                              TelescopeResultsVariable = { default = true, link = "SpecialChar" },
                            
                              TelescopeResultsLineNr = { default = true, link = "LineNr" },
                              TelescopeResultsIdentifier = { default = true, link = "Identifier" },
                              TelescopeResultsNumber = { default = true, link = "Number" },
                              TelescopeResultsComment = { default = true, link = "Comment" },
                              TelescopeResultsSpecialComment = { default = true, link = "SpecialComment" },
                            
                              -- Used for git status Results highlighting
                              TelescopeResultsDiffChange = { default = true, link = "DiffChange" },
                              TelescopeResultsDiffAdd = { default = true, link = "DiffAdd" },
                              TelescopeResultsDiffDelete = { default = true, link = "DiffDelete" },
                              TelescopeResultsDiffUntracked = { default = true, link = "NonText" },
                            }
                            
                            for k, v in pairs(highlights) do
                              vim.api.nvim_set_hl(0, k, v)
                            end
                            
                            -- This is like "<C-R>" in your terminal.
                            --     To use it, do `cmap <C-R> <Plug>(TelescopeFuzzyCommandSearch)
                            vim.keymap.set(
                              "c",
                              "<Plug>(TelescopeFuzzyCommandSearch)",
                              "<C-\\>e \"lua require('telescope.builtin').command_history "
                                .. '{ default_text = [=[" . escape(getcmdline(), \'"\') . "]=] }"<CR><CR>',
                              { silent = true, noremap = true }
                            )
                            
                            vim.api.nvim_create_user_command("Telescope", function(opts)
                              require("telescope.command").load_command(unpack(opts.fargs))
                            end, {
                              nargs = "*",
                              complete = function(_, line)
                                local builtin_list = vim.tbl_keys(require "telescope.builtin")
                                local extensions_list = vim.tbl_keys(require("telescope._extensions").manager)
                            
                                local l = vim.split(line, "%s+")
                                local n = #l - 2
                            
                                if n == 0 then
                                  local commands = { builtin_list, extensions_list }
                                  -- TODO(clason): remove when dropping support for Nvim 0.9
                                  if vim.fn.has "nvim-0.11" == 1 then
                                    commands = vim.iter(commands):flatten():totable()
                                  else
                                    commands = vim.tbl_flatten(commands)
                                  end
                                  table.sort(commands)
                            
                                  return vim.tbl_filter(function(val)
                                    return vim.startswith(val, l[2])
                                  end, commands)
                                end
                            
                                if n == 1 then
                                  local is_extension = vim.tbl_filter(function(val)
                                    return val == l[2]
                                  end, extensions_list)
                            
                                  if #is_extension > 0 then
                                    local extensions_subcommand_dict = require("telescope.command").get_extensions_subcommand()
                                    local commands = extensions_subcommand_dict[l[2]]
                                    table.sort(commands)
                            
                                    return vim.tbl_filter(function(val)
                                      return vim.startswith(val, l[3])
                                    end, commands)
                                  end
                                end
                            
                                local options_list = vim.tbl_keys(require("telescope.config").values)
                                table.sort(options_list)
                            
                                return vim.tbl_filter(function(val)
                                  return vim.startswith(val, l[#l])
                                end, options_list)
                              end,
                            })

SCRIPT  /Users/anon/.local/share/nvim/lazy/zen-mode.nvim/plugin/zen-mode.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000002 if !has('nvim-0.5')
                              echohl WarningMsg
                              echom "ZenMode needs Neovim >= 0.5"
                              echohl None
                              finish
    1              0.000000 endif
    1              0.000002 command! -bar ZenMode lua require("zen-mode").toggle()

SCRIPT  /Users/anon/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
Sourced 1 time
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                            local timer = (vim.uv or vim.loop).new_timer()
                            timer:start(
                              500,
                              0,
                              vim.schedule_wrap(function()
                                local wk = require("which-key")
                                if not wk.did_setup then
                                  wk.setup()
                                end
                              end)
                            )

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
Sourced 1 time
Total time:   0.005446
 Self time:   0.005446

count  total (s)   self (s)
    1              0.000001 lua << EOF
                            require "nvim-treesitter-textobjects".init()
                            EOF

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
Sourced 1 time
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
                            require('treesitter-context').setup()

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-ts-autotag/plugin/nvim-ts-autotag.lua
Sourced 1 time
Total time:   0.000742
 Self time:   0.000742

count  total (s)   self (s)
                            require("nvim-ts-autotag").init()

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
Sourced 1 time
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
                            -- Last Change: 2022 Apr 16
                            
                            if vim.g.loaded_nvim_treesitter then
                              return
                            end
                            vim.g.loaded_nvim_treesitter = true
                            
                            -- setup modules
                            require("nvim-treesitter").setup()
                            
                            local api = vim.api
                            
                            -- define autocommands
                            local augroup = api.nvim_create_augroup("NvimTreesitter", {})
                            
                            api.nvim_create_autocmd("Filetype", {
                              pattern = "query",
                              group = augroup,
                              callback = function()
                                api.nvim_clear_autocmds {
                                  group = augroup,
                                  event = "BufWritePost",
                                }
                                api.nvim_create_autocmd("BufWritePost", {
                                  group = augroup,
                                  buffer = 0,
                                  callback = function(opts)
                                    require("nvim-treesitter.query").invalidate_query_file(opts.file)
                                  end,
                                  desc = "Invalidate query file",
                                })
                              end,
                              desc = "Reload query",
                            })

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-spectre/plugin/spectre.lua
Sourced 1 time
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
                            local function get_arg(str)
                            	local key, value = str:match([=[^([^%s]*)=([^%s]*)$]=])
                            
                            	-- translate string 'true' and 'false' to boolen type
                            	value = value == "true" or value
                            	value = (value == "false" and { false } or { value })[1]
                            
                            	return key, value
                            end
                            
                            vim.api.nvim_create_user_command("Spectre", function(ctx)
                                local spectre = require("spectre")
                            	local args = {}
                            	local user_args
                            	if #ctx.fargs == 1 or vim.tbl_isempty(ctx.fargs) then
                            		user_args = ctx.fargs[1] and ctx.fargs or { "" }
                            	elseif #ctx.fargs > 1 then
                            		user_args = ctx.fargs
                            	end
                            
                            	for _, user_arg in ipairs(user_args) do
                            		if user_arg == "%" then
                            			args["path"] = vim.fn.expand("%")
                            		elseif get_arg(user_arg) == nil then
                            			args["path"] = user_arg
                            		elseif get_arg(user_arg) then
                            			local key, value = get_arg(user_arg)
                            			args[key] = value
                            		end
                            	end
                            
                            	spectre.open(args)
                            end, {
                            	nargs = "*",
                            	complete = "file",
                                desc = "Global find and replace",
                            })

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
Sourced 1 time
Total time:   0.003745
 Self time:   0.003745

count  total (s)   self (s)
                            if vim.g.lspconfig ~= nil then
                              return
                            end
                            vim.g.lspconfig = 1
                            
                            local api, lsp = vim.api, vim.lsp
                            
                            if vim.fn.has 'nvim-0.8' ~= 1 then
                              local version_info = vim.version()
                              local warning_str = string.format(
                                '[lspconfig] requires neovim 0.8 or later. Detected neovim version: 0.%s.%s',
                                version_info.minor,
                                version_info.patch
                              )
                              vim.notify_once(warning_str)
                              return
                            end
                            
                            local completion_sort = function(items)
                              table.sort(items)
                              return items
                            end
                            
                            local lsp_complete_configured_servers = function(arg)
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, require('lspconfig.util').available_servers()))
                            end
                            
                            local lsp_get_active_client_ids = function(arg)
                              local clients = vim.tbl_map(function(client)
                                return ('%d (%s)'):format(client.id, client.name)
                              end, require('lspconfig.util').get_managed_clients())
                            
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, clients))
                            end
                            
                            local get_clients_from_cmd_args = function(arg)
                              local result = {}
                              for id in (arg or ''):gmatch '(%d+)' do
                                result[#result + 1] = lsp.get_client_by_id(tonumber(id))
                              end
                              if #result == 0 then
                                return require('lspconfig.util').get_managed_clients()
                              end
                              return result
                            end
                            
                            for group, hi in pairs {
                              LspInfoBorder = { link = 'Label', default = true },
                              LspInfoList = { link = 'Function', default = true },
                              LspInfoTip = { link = 'Comment', default = true },
                              LspInfoTitle = { link = 'Title', default = true },
                              LspInfoFiletype = { link = 'Type', default = true },
                            } do
                              api.nvim_set_hl(0, group, hi)
                            end
                            
                            -- Called from plugin/lspconfig.vim because it requires knowing that the last
                            -- script in scriptnames to be executed is lspconfig.
                            api.nvim_create_user_command('LspInfo', function()
                              require 'lspconfig.ui.lspinfo'()
                            end, {
                              desc = 'Displays attached, active, and configured language servers',
                            })
                            
                            api.nvim_create_user_command('LspStart', function(info)
                              local server_name = string.len(info.args) > 0 and info.args or nil
                              if server_name then
                                local config = require('lspconfig.configs')[server_name]
                                if config then
                                  config.launch()
                                  return
                                end
                              end
                            
                              local matching_configs = require('lspconfig.util').get_config_by_ft(vim.bo.filetype)
                              for _, config in ipairs(matching_configs) do
                                config.launch()
                              end
                            end, {
                              desc = 'Manually launches a language server',
                              nargs = '?',
                              complete = lsp_complete_configured_servers,
                            })
                            
                            api.nvim_create_user_command('LspRestart', function(info)
                              local detach_clients = {}
                              for _, client in ipairs(get_clients_from_cmd_args(info.args)) do
                                client.stop()
                                if vim.tbl_count(client.attached_buffers) > 0 then
                                  detach_clients[client.name] = { client, lsp.get_buffers_by_client_id(client.id) }
                                end
                              end
                              local timer = vim.loop.new_timer()
                              timer:start(
                                500,
                                100,
                                vim.schedule_wrap(function()
                                  for client_name, tuple in pairs(detach_clients) do
                                    if require('lspconfig.configs')[client_name] then
                                      local client, attached_buffers = unpack(tuple)
                                      if client.is_stopped() then
                                        for _, buf in pairs(attached_buffers) do
                                          require('lspconfig.configs')[client_name].launch(buf)
                                        end
                                        detach_clients[client_name] = nil
                                      end
                                    end
                                  end
                            
                                  if next(detach_clients) == nil and not timer:is_closing() then
                                    timer:close()
                                  end
                                end)
                              )
                            end, {
                              desc = 'Manually restart the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspStop', function(info)
                              local current_buf = vim.api.nvim_get_current_buf()
                              local server_id, force
                              local arguments = vim.split(info.args, '%s')
                              for _, v in pairs(arguments) do
                                if v == '++force' then
                                  force = true
                                elseif v:find '^[0-9]+$' then
                                  server_id = v
                                end
                              end
                            
                              if not server_id then
                                local servers_on_buffer = require('lspconfig.util').get_lsp_clients { bufnr = current_buf }
                                for _, client in ipairs(servers_on_buffer) do
                                  if client.attached_buffers[current_buf] then
                                    client.stop(force)
                                  end
                                end
                              else
                                for _, client in ipairs(get_clients_from_cmd_args(server_id)) do
                                  client.stop(force)
                                end
                              end
                            end, {
                              desc = 'Manually stops the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspLog', function()
                              vim.cmd(string.format('tabnew %s', lsp.get_log_path()))
                            end, {
                              desc = 'Opens the Nvim LSP client log.',
                            })

SCRIPT  /Users/anon/.local/share/nvim/lazy/omnisharp-extended-lsp.nvim/plugin/omnisharp_extended.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000004 if !has('nvim-0.5.1')
                              echoerr "omnisharp-extended-lsp.nvim requires at least nvim-0.5.1. Please update or uninstall"
                              finish
    1              0.000001 end

SCRIPT  /Users/anon/.local/share/nvim/lazy/log-highlight.nvim/ftdetect/log.vim
Sourced 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005 au BufNewFile,BufRead  *{.,_}log  set filetype=log

SCRIPT  /Users/anon/.local/share/nvim/lazy/Comment.nvim/plugin/Comment.lua
Sourced 1 time
Total time:   0.001334
 Self time:   0.001334

count  total (s)   self (s)
                            local K = vim.keymap.set
                            local call = require('Comment.api').call
                            
                            ---@mod comment.keybindings Keybindings
                            ---@brief [[
                            ---Comment.nvim provides default keybindings for (un)comment your code. These
                            ---keybinds are enabled upon calling |comment.usage.setup| and can be configured
                            ---or disabled, if desired.
                            ---
                            ---Basic: ~
                            ---
                            ---  *gc*
                            ---  *gb*
                            ---  *gc[count]{motion}*
                            ---  *gb[count]{motion}*
                            ---
                            ---      Toggle comment on a region using linewise/blockwise comment. In 'NORMAL'
                            ---      mode, it uses 'Operator-Pending' mode to listen for an operator/motion.
                            ---      In 'VISUAL' mode it simply comment the selected region.
                            ---
                            ---  *gcc*
                            ---  *gbc*
                            ---  *[count]gcc*
                            ---  *[count]gbc*
                            ---
                            ---      Toggle comment on the current line using linewise/blockwise comment. If
                            ---      prefixed with a 'v:count' then it will comment over the number of lines
                            ---      corresponding to the {count}. These are only available in 'NORMAL' mode.
                            ---
                            ---
                            ---Extra: ~
                            ---
                            ---  *gco* - Inserts comment below and enters INSERT mode
                            ---  *gcO* - Inserts comment above and enters INSERT mode
                            ---  *gcA* - Inserts comment at the end of line and enters INSERT mode
                            ---@brief ]]
                            
                            ---@mod comment.plugmap Plug Mappings
                            ---@brief [[
                            ---Comment.nvim provides <Plug> mappings for most commonly used actions. These
                            ---are enabled by default and can be used to make custom keybindings. All plug
                            ---mappings have support for dot-repeat except VISUAL mode keybindings. To create
                            ---custom comment function, check out 'comment.api' section.
                            ---
                            ---  *<Plug>(comment_toggle_linewise)*
                            ---  *<Plug>(comment_toggle_blockwise)*
                            ---
                            ---     Toggle comment on a region with linewise/blockwise comment in NORMAL mode.
                            ---     using |Operator-Pending| mode (or |g@|) to get the region to comment.
                            ---     These powers the |gc| and |gb| keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_current)*
                            ---  *<Plug>(comment_toggle_blockwise_current)*
                            ---
                            ---     Toggle comment on the current line with linewise/blockwise comment in
                            ---     NORMAL mode. These powers the |gcc| and 'gbc' keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_count)*
                            ---  *<Plug>(comment_toggle_blockwise_count)*
                            ---
                            ---     Toggle comment on a region using 'v:count' with linewise/blockwise comment
                            ---     in NORMAL mode. These powers the |[count]gcc| and |[count]gbc| keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_visual)*
                            ---  *<Plug>(comment_toggle_blockwise_visual)*
                            ---
                            ---     Toggle comment on the selected region with linewise/blockwise comment in
                            ---     NORMAL mode. These powers the |{visual}gc| and |{visual}gb| keybindings.
                            ---
                            ---Usage: ~
                            --->lua
                            ---    -- Toggle current line or with count
                            ---    vim.keymap.set('n', 'gcc', function()
                            ---        return vim.v.count == 0
                            ---            and '<Plug>(comment_toggle_linewise_current)'
                            ---            or '<Plug>(comment_toggle_linewise_count)'
                            ---    end, { expr = true })
                            ---
                            ---    -- Toggle in Op-pending mode
                            ---    vim.keymap.set('n', 'gc', '<Plug>(comment_toggle_linewise)')
                            ---
                            ---    -- Toggle in VISUAL mode
                            ---    vim.keymap.set('x', 'gc', '<Plug>(comment_toggle_linewise_visual)')
                            ---<
                            ---@brief ]]
                            ---@export plugs
                            
                            -- Operator-Pending mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise)',
                                call('toggle.linewise', 'g@'),
                                { expr = true, desc = 'Comment toggle linewise' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise)',
                                call('toggle.blockwise', 'g@'),
                                { expr = true, desc = 'Comment toggle blockwise' }
                            )
                            
                            -- Toggle mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise_current)',
                                call('toggle.linewise.current', 'g@$'),
                                { expr = true, desc = 'Comment toggle current line' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise_current)',
                                call('toggle.blockwise.current', 'g@$'),
                                { expr = true, desc = 'Comment toggle current block' }
                            )
                            
                            -- Count mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise_count)',
                                call('toggle.linewise.count_repeat', 'g@$'),
                                { expr = true, desc = 'Comment toggle linewise with count' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise_count)',
                                call('toggle.blockwise.count_repeat', 'g@$'),
                                { expr = true, desc = 'Comment toggle blockwise with count' }
                            )
                            
                            -- Visual-Mode mappings
                            K(
                                'x',
                                '<Plug>(comment_toggle_linewise_visual)',
                                '<ESC><CMD>lua require("Comment.api").locked("toggle.linewise")(vim.fn.visualmode())<CR>',
                                { desc = 'Comment toggle linewise (visual)' }
                            )
                            K(
                                'x',
                                '<Plug>(comment_toggle_blockwise_visual)',
                                '<ESC><CMD>lua require("Comment.api").locked("toggle.blockwise")(vim.fn.visualmode())<CR>',
                                { desc = 'Comment toggle blockwise (visual)' }
                            )

SCRIPT  /Users/anon/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
Sourced 1 time
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
                            " sleuth.vim - Heuristically set buffer options
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.0
                            " GetLatestVimScripts: 4375 1 :AutoInstall: sleuth.vim
                            
    1              0.000003 if exists("#polyglot-sleuth")
                              autocmd! polyglot-sleuth
                              augroup! polyglot-sleuth
                              unlet! g:loaded_sleuth
                              let s:polyglot = 1
    1              0.000000 endif
                            
    1              0.000003 if exists("g:loaded_sleuth") || v:version < 700 || &cp
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_sleuth = 1
    1              0.000001 lockvar g:loaded_sleuth
                            
    1              0.000002 function! s:Warn(msg, ...) abort
                              if !get(a:000, 0, 0)
                                echohl WarningMsg
                                echo a:msg
                                echohl NONE
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 if exists('+shellslash')
                              function! s:Slash(path) abort
                                return tr(a:path, '\', '/')
                              endfunction
    1              0.000000 else
    1              0.000000   function! s:Slash(path) abort
                                return a:path
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:Guess(source, detected, lines) abort
                              let has_heredocs = a:detected.filetype =~# '^\%(perl\|php\|ruby\|[cz]\=sh\|bash\)$'
                              let options = {}
                              let heuristics = {'spaces': 0, 'hard': 0, 'soft': 0, 'checked': 0, 'indents': {}}
                              let tabstop = get(a:detected.options, 'tabstop', get(a:detected.defaults, 'tabstop', [8]))[0]
                              let softtab = repeat(' ', tabstop)
                              let waiting_on = ''
                              let prev_indent = -1
                              let prev_line = ''
                            
                              for line in a:lines
                                if len(waiting_on)
                                  if line =~# waiting_on
                                    let waiting_on = ''
                                    let prev_indent = -1
                                    let prev_line = ''
                                  endif
                                  continue
                                elseif line =~# '^\s*$'
                                  continue
                                elseif a:detected.filetype ==# 'python' && prev_line[-1:-1] =~# '[[\({]'
                                  let prev_indent = -1
                                  let prev_line = ''
                                  continue
                                elseif line =~# '^=\w' && line !~# '^=\%(end\|cut\)\>'
                                  let waiting_on = '^=\%(end\|cut\)\>'
                                elseif line =~# '^@@\+ -\d\+,\d\+ '
                                  let waiting_on = '^$'
                                elseif line !~# '[/<"`]'
                                  " No need to do other checks
                                elseif line =~# '^\s*/\*' && line !~# '\*/'
                                  let waiting_on = '\*/'
                                elseif line =~# '^\s*<\!--' && line !~# '-->'
                                  let waiting_on = '-->'
                                elseif line =~# '^[^"]*"""'
                                  let waiting_on = '^[^"]*"""'
                                elseif a:detected.filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                  let waiting_on = '^[^`]*`[^`]*$'
                                elseif has_heredocs
                                  let waiting_on = matchstr(line, '<<\s*\([''"]\=\)\zs\w\+\ze\1[^''"`<>]*$')
                                  if len(waiting_on)
                                    let waiting_on = '^' . waiting_on . '$'
                                  endif
                                endif
                            
                                let indent = len(matchstr(substitute(line, '\t', softtab, 'g'), '^ *'))
                                if line =~# '^\t'
                                  let heuristics.hard += 1
                                elseif line =~# '^' . softtab
                                  let heuristics.soft += 1
                                endif
                                if line =~# '^  '
                                  let heuristics.spaces += 1
                                endif
                                let increment = prev_indent < 0 ? 0 : indent - prev_indent
                                let prev_indent = indent
                                let prev_line = line
                                if increment > 1 && (increment < 4 || increment % 4 == 0)
                                  if has_key(heuristics.indents, increment)
                                    let heuristics.indents[increment] += 1
                                  else
                                    let heuristics.indents[increment] = 1
                                  endif
                                  let heuristics.checked += 1
                                endif
                                if heuristics.checked >= 32 && (heuristics.hard > 3 || heuristics.soft > 3) && get(heuristics.indents, increment) * 2 > heuristics.checked
                                  if heuristics.spaces
                                    break
                                  elseif !exists('no_space_indent')
                                    let no_space_indent = stridx("\n" . join(a:lines, "\n"), "\n  ") < 0
                                    if no_space_indent
                                      break
                                    endif
                                  endif
                                  break
                                endif
                              endfor
                            
                              let a:detected.heuristics[a:source] = heuristics
                            
                              let max_frequency = 0
                              for [shiftwidth, frequency] in items(heuristics.indents)
                                if frequency > max_frequency || frequency == max_frequency && +shiftwidth < get(options, 'shiftwidth')
                                  let options.shiftwidth = +shiftwidth
                                  let max_frequency = frequency
                                endif
                              endfor
                            
                              if heuristics.hard && !heuristics.spaces &&
                                    \ !has_key(a:detected.options, 'tabstop')
                                let options = {'expandtab': 0, 'shiftwidth': 0}
                              elseif heuristics.hard > heuristics.soft
                                let options.expandtab = 0
                                let options.tabstop = tabstop
                              else
                                if heuristics.soft
                                  let options.expandtab = 1
                                endif
                                if heuristics.hard || has_key(a:detected.options, 'tabstop') ||
                                      \ stridx(join(a:lines, "\n"), "\t") >= 0
                                  let options.tabstop = tabstop
                                elseif !&g:shiftwidth && has_key(options, 'shiftwidth') &&
                                      \ !has_key(a:detected.options, 'shiftwidth')
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = 0
                                endif
                              endif
                            
                              call map(options, '[v:val, a:source]')
                              call extend(a:detected.options, options, 'keep')
                            endfunction
                            
    1              0.000001 function! s:Capture(cmd) abort
                              redir => capture
                              silent execute a:cmd
                              redir END
                              return capture
                            endfunction
                            
    1              0.000003 let s:modeline_numbers = {
                                  \ 'shiftwidth': 'shiftwidth', 'sw': 'shiftwidth',
                                  \ 'tabstop': 'tabstop', 'ts': 'tabstop',
                                  \ 'textwidth': 'textwidth', 'tw': 'textwidth',
                                  \ }
    1              0.000002 let s:modeline_booleans = {
                                  \ 'expandtab': 'expandtab', 'et': 'expandtab',
                                  \ 'fixendofline': 'fixendofline', 'fixeol': 'fixendofline',
                                  \ }
    1              0.000001 function! s:ParseOptions(declarations, into, ...) abort
                              for option in a:declarations
                                if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
                                  let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
                                elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
                                  let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
                                elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
                                  let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
                                endif
                                if option ==# 'nomodeline' || option ==# 'noml'
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000000 function! s:ModelineOptions() abort
                              let options = {}
                              if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' &&
                                    \ s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
                                return options
                              endif
                              let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
                              if line('$') > 2 * modelines
                                let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
                              else
                                let lnums = range(1, line('$'))
                              endif
                              for lnum in lnums
                                if s:ParseOptions(split(matchstr(getline(lnum),
                                      \ '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'),
                                      \ '[[:space:]:]\+'), options, 'modeline', lnum)
                                  break
                                endif
                              endfor
                              return options
                            endfunction
                            
    1              0.000002 let s:fnmatch_replacements = {
                                  \ '.': '\.', '\%': '%', '\(': '(', '\)': ')', '\{': '{', '\}': '}', '\_': '_',
                                  \ '?': '[^/]', '*': '[^/]*', '/**/*': '/.*', '/**/': '/\%(.*/\)\=', '**': '.*'}
    1              0.000000 function! s:FnmatchReplace(pat) abort
                              if has_key(s:fnmatch_replacements, a:pat)
                                return s:fnmatch_replacements[a:pat]
                              elseif len(a:pat) ==# 1
                                return '\' . a:pat
                              elseif a:pat =~# '^{[+-]\=\d\+\.\.[+-]\=\d\+}$'
                                return '\%(' . join(range(matchstr(a:pat, '[+-]\=\d\+'), matchstr(a:pat, '\.\.\zs[+-]\=\d\+')), '\|') . '\)'
                              elseif a:pat =~# '^{.*\\\@<!\%(\\\\\)*,.*}$'
                                let done = []
                                let rest = a:pat[0:-2]
                                while !empty(rest)
                                  let match = matchstr(rest, '\%(\\.\|{[^\{}]*}\|[^,]\)*', 1)
                                  let rest = strpart(rest, len(match) + 1)
                                  call add(done, s:FnmatchTranslate(match))
                                endwhile
                                return '\%(' . join(done, '\|') . '\)'
                              elseif a:pat =~# '^{.*}$'
                                return '{' . s:FnmatchTranslate(a:pat[1:-2]) . '}'
                              elseif a:pat =~# '^\[!'
                                return '[^' . a:pat[2:-1]
                              else
                                return a:pat
                              endif
                            endfunction
                            
    1              0.000001 function! s:FnmatchTranslate(pat) abort
                              return substitute(a:pat, '\\.\|/\*\*/\*\=\|\*\*\=\|\[[!^]\=\]\=[^]/]*\]\|{\%(\\.\|[^{}]\|{[^\{}]*}\)*}\|[?.\~^$[]', '\=s:FnmatchReplace(submatch(0))', 'g')
                            endfunction
                            
    1              0.000000 function! s:ReadEditorConfig(absolute_path) abort
                              try
                                let lines = readfile(a:absolute_path)
                              catch
                                let lines = []
                              endtry
                              let prefix = '\m\C^' . escape(fnamemodify(a:absolute_path, ':h'), '][^$.*\~')
                              let preamble = {}
                              let pairs = preamble
                              let sections = []
                              let i = 0
                              while i < len(lines)
                                let line = lines[i]
                                let i += 1
                                let line = substitute(line, '^[[:space:]]*\|[[:space:]]*\%([^[:space:]]\@<![;#].*\)\=$', '', 'g')
                                let match = matchlist(line, '^\%(\[\(\%(\\.\|[^\;#]\)*\)\]\|\([^[:space:]]\@=[^;#=:]*[^;#=:[:space:]]\)[[:space:]]*[=:][[:space:]]*\(.*\)\)$')
                                if len(get(match, 2, ''))
                                  let pairs[tolower(match[2])] = [match[3], a:absolute_path, i]
                                elseif len(get(match, 1, '')) && len(get(match, 1, '')) <= 4096
                                  if match[1] =~# '^/'
                                    let pattern = match[1]
                                  elseif match[1] =~# '/'
                                    let pattern = '/' . match[1]
                                  else
                                    let pattern = '/**/' . match[1]
                                  endif
                                  let pairs = {}
                                  call add(sections, [prefix . s:FnmatchTranslate(pattern) . '$', pairs])
                                endif
                              endwhile
                              return [preamble, sections]
                            endfunction
                            
    1              0.000001 let s:editorconfig_cache = {}
    1              0.000000 function! s:DetectEditorConfig(absolute_path, ...) abort
                              if empty(a:absolute_path)
                                return [{}, '']
                              endif
                              let root = ''
                              let tail = a:0 ? a:1 : '.editorconfig'
                              let dir = fnamemodify(a:absolute_path, ':h')
                              let previous_dir = ''
                              let sections = []
                              let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
                              while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
                                let head = substitute(dir, '/\=$', '/', '')
                                let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
                                if read_from is# ''
                                  break
                                elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
                                  let read_from = simplify(head . read_from)
                                endif
                                let ftime = type(read_from) == type('') ? getftime(read_from) : -1
                                let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
                                if ftime != cachetime
                                  let econfig = s:ReadEditorConfig(read_from)
                                  let s:editorconfig_cache[read_from] = [ftime] + econfig
                                  lockvar! s:editorconfig_cache[read_from]
                                  unlockvar s:editorconfig_cache[read_from]
                                endif
                                call extend(sections, econfig[1], 'keep')
                                if get(econfig[0], 'root', [''])[0] ==? 'true'
                                  let root = head
                                  break
                                endif
                                let previous_dir = dir
                                let dir = fnamemodify(dir, ':h')
                              endwhile
                            
                              let config = {}
                              for [pattern, pairs] in sections
                                if a:absolute_path =~# pattern
                                  call extend(config, pairs)
                                endif
                              endfor
                            
                              return [config, root]
                            endfunction
                            
    1              0.000002 let s:editorconfig_bomb = {
                                  \ 'utf-8':     0,
                                  \ 'utf-8-bom': 1,
                                  \ 'utf-16be':  1,
                                  \ 'utf-16le':  1,
                                  \ 'latin1':    0,
                                  \ }
                            
    1              0.000001 let s:editorconfig_fileformat = {
                                  \ 'cr':   'mac',
                                  \ 'crlf': 'dos',
                                  \ 'lf':   'unix',
                                  \ }
                            
    1              0.000001 function! s:EditorConfigToOptions(pairs) abort
                              let options = {}
                              let pairs = map(copy(a:pairs), 'v:val[0]')
                              let sources = map(copy(a:pairs), 'v:val[1:-1]')
                              call filter(pairs, 'v:val !=? "unset"')
                            
                              if get(pairs, 'indent_style', '') ==? 'tab'
                                let options.expandtab = [0] + sources.indent_style
                              elseif get(pairs, 'indent_style', '') ==? 'space'
                                let options.expandtab = [1] + sources.indent_style
                              endif
                            
                              if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
                                let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
                                if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = [0] + sources.indent_size
                                endif
                              endif
                            
                              if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
                                let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
                                if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
                                  let options.shiftwidth = [0] + options.tabstop[1:-1]
                                endif
                              endif
                            
                              if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
                                let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
                              endif
                            
                              if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
                                let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
                                let options.fixendofline = copy(options.endofline)
                              endif
                            
                              let eol = tolower(get(pairs, 'end_of_line', ''))
                              if has_key(s:editorconfig_fileformat, eol)
                                let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
                              endif
                            
                              let charset = tolower(get(pairs, 'charset', ''))
                              if has_key(s:editorconfig_bomb, charset)
                                let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
                                let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
                              endif
                            
                              let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
                              if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
                                let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
                              endif
                            
                              return options
                            endfunction
                            
    1              0.000000 function! s:Ready(detected) abort
                              return has_key(a:detected.options, 'expandtab') && has_key(a:detected.options, 'shiftwidth')
                            endfunction
                            
    1              0.000001 let s:booleans = {'expandtab': 1, 'fixendofline': 1, 'endofline': 1, 'bomb': 1}
    1              0.000001 let s:safe_options = ['expandtab', 'shiftwidth', 'tabstop', 'textwidth', 'fixendofline']
    1              0.000002 let s:all_options = s:safe_options + ['endofline', 'fileformat', 'fileencoding', 'bomb']
    1              0.000002 let s:short_options = {
                                  \ 'expandtab': 'et', 'shiftwidth': 'sw', 'tabstop': 'ts',
                                  \ 'textwidth': 'tw', 'fixendofline': 'fixeol',
                                  \ 'endofline': 'eol', 'fileformat': 'ff', 'fileencoding': 'fenc'}
                            
    1              0.000001 function! s:Apply(detected, permitted_options, silent) abort
                              let options = extend(copy(a:detected.defaults), a:detected.options)
                              if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
                                let options.tabstop = options.shiftwidth
                                let options.shiftwidth = a:detected.defaults.shiftwidth
                              endif
                              if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
                                let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
                              endif
                              if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
                                let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
                              endif
                              let msg = ''
                              let cmd = 'setlocal'
                              for option in a:permitted_options
                                if !exists('&' . option) || !has_key(options, option) ||
                                      \ !&l:modifiable && index(s:safe_options, option) == -1
                                  continue
                                endif
                                let value = options[option]
                                if has_key(s:booleans, option)
                                  let setting = (value[0] ? '' : 'no') . option
                                else
                                  let setting = option . '=' . value[0]
                                endif
                                if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
                                  let cmd .= ' ' . setting
                                endif
                                if !&verbose || a:silent
                                  if has_key(s:booleans, option)
                                    let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
                                  else
                                    let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
                                  endif
                                  continue
                                endif
                                if len(value) > 1
                                  if value[1] ==# a:detected.bufname
                                    let file = '%'
                                  else
                                    let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
                                    if file !=# value[1] && file[0:0] !=# '~'
                                      let file = './' . file
                                    endif
                                  endif
                                  if len(value) > 2
                                    let file .= ' line ' . value[2]
                                  endif
                                  echo printf(':setlocal %-21s " from %s', setting, file)
                                else
                                  echo ':setlocal ' . setting
                                endif
                              endfor
                              if !&verbose && !empty(msg) && !a:silent
                                echo ':setlocal' . msg
                              endif
                              if has_key(options, 'shiftwidth')
                                let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
                              else
                                call s:Warn(':Sleuth failed to detect indent settings', a:silent)
                              endif
                              return cmd ==# 'setlocal' ? '' : cmd
                            endfunction
                            
    1              0.000000 function! s:UserOptions(ft, name) abort
                              if exists('b:sleuth_' . a:name)
                                let source = 'b:sleuth_' . a:name
                              elseif exists('g:sleuth_' . a:ft . '_' . a:name)
                                let source = 'g:sleuth_' . a:ft . '_' . a:name
                              endif
                              if !exists('l:source') || type(eval(source)) == type(function('tr'))
                                return {}
                              endif
                              let val = eval(source)
                              let options = {}
                              if type(val) == type('')
                                call s:ParseOptions(split(substitute(val, '\S\@<![=+]\S\@=', 'ft=', 'g'), '[[:space:]:,]\+'), options, source)
                                if has_key(options, 'filetype')
                                  call extend(options, s:UserOptions(remove(options, 'filetype')[0], a:name), 'keep')
                                endif
                                if has_key(options, 'tabstop')
                                  call extend(options, {'shiftwidth': [0, source], 'expandtab': [0, source]}, 'keep')
                                elseif has_key(options, 'shiftwidth')
                                  call extend(options, {'expandtab': [1, source]}, 'keep')
                                endif
                              elseif type(val) == type([])
                                call s:ParseOptions(val, options, source)
                              endif
                              call filter(options, 'index(s:safe_options, v:key) >= 0')
                              return options
                            endfunction
                            
    1              0.000000 function! s:DetectDeclared() abort
                              let detected = {'bufname': s:Slash(@%), 'declared': {}}
                              let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
                              if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
                                let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
                                let absolute_or_empty = 1
                              endif
                              let detected.path = absolute_or_empty ? detected.bufname : ''
                              let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
                              if len(pre) && exists('*' . pre . 'Real')
                                let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
                              endif
                            
                              try
                                if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
                                  let detected.path = ''
                                endif
                              catch
                              endtry
                              let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
                              call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
                              call extend(detected.declared, s:ModelineOptions())
                              return detected
                            endfunction
                            
    1              0.000000 function! s:DetectHeuristics(into) abort
                              let detected = a:into
                              let filetype = split(&l:filetype, '\.', 1)[0]
                              if get(detected, 'filetype', '*') ==# filetype
                                return detected
                              endif
                              let detected.filetype = filetype
                              let options = copy(detected.declared)
                              let detected.options = options
                              let detected.heuristics = {}
                              if has_key(detected, 'patterns')
                                call remove(detected, 'patterns')
                              endif
                              let detected.defaults = s:UserOptions(filetype, 'defaults')
                              if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
                                return detected
                              endif
                              if s:Ready(detected)
                                return detected
                              endif
                            
                              let lines = getline(1, 1024)
                              call s:Guess(detected.bufname, detected, lines)
                              if s:Ready(detected)
                                return detected
                              elseif get(options, 'shiftwidth', [4])[0] < 4 && stridx(join(lines, "\n"), "\t") == -1
                                let options.expandtab = [1, detected.bufname]
                                return detected
                              endif
                              let dir = len(detected.path) ? fnamemodify(detected.path, ':h') : ''
                              let root = len(detected.root) ? fnamemodify(detected.root, ':h') : dir ==# s:Slash(expand('~')) ? dir : fnamemodify(dir, ':h')
                              if detected.bufname =~# '^\a\a\+:' || root ==# '.' || !isdirectory(root)
                                let dir = ''
                              endif
                              let c = get(b:, 'sleuth_neighbor_limit', get(g:, 'sleuth_neighbor_limit', 8))
                              if c <= 0 || empty(dir)
                                let detected.patterns = []
                              elseif type(get(b:, 'sleuth_globs')) == type([])
                                let detected.patterns = b:sleuth_globs
                              elseif type(get(g:, 'sleuth_' . detected.filetype . '_globs')) == type([])
                                let detected.patterns = get(g:, 'sleuth_' . detected.filetype . '_globs')
                              else
                                let detected.patterns = ['*' . matchstr(detected.bufname, '/\@<!\.[^][{}*?$~\`./]\+$')]
                                if detected.patterns ==# ['*']
                                  let detected.patterns = [matchstr(detected.bufname, '/\zs[^][{}*?$~\`/]\+\ze/\=$')]
                                  let dir = fnamemodify(dir, ':h')
                                  if empty(detected.patterns[0])
                                    let detected.patterns = []
                                  endif
                                endif
                              endif
                              while c > 0 && dir !~# '^$\|^//[^/]*$' && dir !=# fnamemodify(dir, ':h')
                                for pattern in detected.patterns
                                  for neighbor in split(glob(dir.'/'.pattern), "\n")[0:7]
                                    if neighbor !=# detected.path && filereadable(neighbor)
                                      call s:Guess(neighbor, detected, readfile(neighbor, '', 256))
                                      let c -= 1
                                    endif
                                    if s:Ready(detected)
                                      return detected
                                    endif
                                    if c <= 0
                                      break
                                    endif
                                  endfor
                                  if c <= 0
                                    break
                                  endif
                                endfor
                                if len(dir) <= len(root)
                                  break
                                endif
                                let dir = fnamemodify(dir, ':h')
                              endwhile
                              if !has_key(options, 'shiftwidth')
                                let detected.options = copy(detected.declared)
                              endif
                              return detected
                            endfunction
                            
    1              0.000001 function! s:Init(redetect, unsafe, do_filetype, silent) abort
                              if !a:redetect && exists('b:sleuth.defaults')
                                let detected = b:sleuth
                              endif
                              unlet! b:sleuth
                              if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
                                return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
                              endif
                              if &l:filetype ==# 'netrw'
                                return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
                              endif
                              if &l:binary
                                return s:Warn(':Sleuth disabled for binary files', a:silent)
                              endif
                              if !exists('detected')
                                let detected = s:DetectDeclared()
                              endif
                              let setfiletype = ''
                              if a:do_filetype && has_key(detected.declared, 'filetype')
                                let filetype = detected.declared.filetype[0]
                                if filetype !=# &l:filetype || empty(filetype)
                                  let setfiletype = 'setlocal filetype=' . filetype
                                else
                                  let setfiletype = 'setfiletype ' . filetype
                                endif
                              endif
                              exe setfiletype
                              call s:DetectHeuristics(detected)
                              let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
                              let b:sleuth = detected
                              if exists('s:polyglot') && !a:silent
                                call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
                                call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
                                call s:Warn('corresponding feature in your vimrc:')
                                call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
                              endif
                              return cmd
                            endfunction
                            
    1              0.000000 function! s:AutoInit() abort
                              return s:Init(1, 1, 1, 1)
                            endfunction
                            
    1              0.000001 function! s:Sleuth(line1, line2, range, bang, mods, args) abort
                              let safe = a:bang || expand("<sfile>") =~# '\%(^\|\.\.\)FileType '
                              return s:Init(!a:bang, !safe, !safe, 0)
                            endfunction
                            
    1              0.000002 if !exists('g:did_indent_on') && !get(g:, 'sleuth_no_filetype_indent_on')
                              filetype indent on
    1              0.000001 elseif !exists('g:did_load_filetypes')
                              filetype on
    1              0.000000 endif
                            
    1              0.000000 function! SleuthIndicator() abort
                              let sw = &shiftwidth ? &shiftwidth : &tabstop
                              if &expandtab
                                let ind = 'sw='.sw
                              elseif &tabstop == sw
                                let ind = 'ts='.&tabstop
                              else
                                let ind = 'sw='.sw.',ts='.&tabstop
                              endif
                              if &textwidth
                                let ind .= ',tw='.&textwidth
                              endif
                              if exists('&fixendofline') && !&fixendofline && !&endofline
                                let ind .= ',noeol'
                              endif
                              return ind
                            endfunction
                            
    1              0.000000 augroup sleuth
    1              0.000003   autocmd!
    1              0.000002   autocmd BufNewFile,BufReadPost * nested
                                    \ if get(g:, 'sleuth_automatic', 1)
                                    \ | exe s:AutoInit() | endif
    1              0.000001   autocmd BufFilePost * nested
                                    \ if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1)
                                    \ | exe s:AutoInit() | endif
    1              0.000001   autocmd FileType * nested
                                    \ if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
    1              0.000001   autocmd User Flags call Hoist('buffer', 5, 'SleuthIndicator')
    1              0.000000 augroup END
                            
    1              0.000005 command! -bar -bang Sleuth exe s:Sleuth(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)

SCRIPT  /Users/anon/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
Sourced 1 time
Total time:   0.000336
 Self time:   0.000336

count  total (s)   self (s)
                            local api = vim.api
                            if not api.nvim_create_user_command then
                              return
                            end
                            
                            local cmd = api.nvim_create_user_command
                            cmd('DapSetLogLevel',
                              function(opts)
                                require('dap').set_log_level(unpack(opts.fargs))
                              end,
                              {
                                nargs = 1,
                                complete = function()
                                  return vim.tbl_keys(require('dap.log').levels)
                                end
                              }
                            )
                            cmd('DapShowLog', 'split | e ' .. vim.fn.stdpath('cache') .. '/dap.log | normal! G', {})
                            cmd('DapContinue', function() require('dap').continue() end, { nargs = 0 })
                            cmd('DapToggleBreakpoint', function() require('dap').toggle_breakpoint() end, { nargs = 0 })
                            cmd('DapToggleRepl', function() require('dap.repl').toggle() end, { nargs = 0 })
                            cmd('DapStepOver', function() require('dap').step_over() end, { nargs = 0 })
                            cmd('DapStepInto', function() require('dap').step_into() end, { nargs = 0 })
                            cmd('DapStepOut', function() require('dap').step_out() end, { nargs = 0 })
                            cmd('DapTerminate', function() require('dap').terminate() end, { nargs = 0 })
                            cmd('DapDisconnect', function() require('dap').disconnect({ terminateDebuggee = false }) end, { nargs = 0 })
                            cmd('DapLoadLaunchJSON', function() require('dap.ext.vscode').load_launchjs() end, { nargs = 0 })
                            cmd('DapRestartFrame', function() require('dap').restart_frame() end, { nargs = 0 })
                            
                            local function dapnew(args)
                              local dap = require("dap")
                              local fargs = args.fargs
                              if not next(fargs) then
                                dap.continue({ new = true })
                                return
                              end
                              local bufnr = api.nvim_get_current_buf()
                              require("dap.async").run(function()
                                for _, get_configs in pairs(dap.providers.configs) do
                                  local configs = get_configs(bufnr)
                                  for _, config in ipairs(configs) do
                                    if vim.tbl_contains(fargs, config.name) then
                                      dap.run(config)
                                    end
                                  end
                                end
                              end)
                            end
                            cmd("DapNew", dapnew, {
                              nargs = "*",
                              desc = "Start one or more new debug sessions",
                              complete = function ()
                                local bufnr = api.nvim_get_current_buf()
                                local dap = require("dap")
                                local candidates = {}
                                local done = false
                                require("dap.async").run(function()
                                  for _, get_configs in pairs(dap.providers.configs) do
                                    local configs = get_configs(bufnr)
                                    for _, config in ipairs(configs) do
                                      local name = config.name:gsub(" ", "\\ ")
                                      table.insert(candidates, name)
                                    end
                                  end
                                  done = true
                                end)
                                vim.wait(2000, function() return done == true end)
                                return candidates
                              end
                            })
                            
                            cmd("DapEval", function(params)
                              local oldbuf = api.nvim_get_current_buf()
                              local name = string.format("dap-eval://%s", vim.bo[oldbuf].filetype)
                              if params.smods.vertical then
                                vim.cmd.vsplit({name})
                              elseif params.smods.tab == 1 then
                                vim.cmd.tabedit(name)
                              else
                                local size = math.max(5, math.floor(vim.o.lines * 1/5))
                                vim.cmd.split({name, mods = params.smods, range = { size }})
                              end
                              local newbuf = api.nvim_get_current_buf()
                              if params.range ~= 0 then
                                local lines = api.nvim_buf_get_lines(oldbuf, params.line1 -1 , params.line2, true)
                                local indent = math.huge
                                for _, line in ipairs(lines) do
                                  indent = math.min(line:find("[^ ]") or math.huge, indent)
                                end
                                if indent ~= math.huge and indent > 0 then
                                  for i, line in ipairs(lines) do
                                    lines[i] = line:sub(indent)
                                  end
                                end
                                api.nvim_buf_set_lines(newbuf, 0, -1, true, lines)
                                vim.bo[newbuf].modified = false
                              end
                              if params.bang then
                                vim.cmd.w()
                              end
                            end, {
                              nargs = 0,
                              range = "%",
                              bang = true,
                              bar = true,
                              desc = "Create a new window & buffer to evaluate expressions",
                            })
                            
                            
                            if api.nvim_create_autocmd then
                              local launchjson_group = api.nvim_create_augroup('dap-launch.json', { clear = true })
                              local pattern =  '*/.vscode/launch.json'
                              api.nvim_create_autocmd('BufNewFile', {
                                group = launchjson_group,
                                pattern = pattern,
                                callback = function(args)
                                  local lines = {
                                    '{',
                                    '   "$schema": "https://raw.githubusercontent.com/mfussenegger/dapconfig-schema/master/dapconfig-schema.json",',
                                    '   "version": "0.2.0",',
                                    '   "configurations": [',
                                    '       {',
                                    '           "type": "<adapter-name>",',
                                    '           "request": "launch",',
                                    '           "name": "Launch"',
                                    '       }',
                                    '   ]',
                                    '}'
                                  }
                                  api.nvim_buf_set_lines(args.buf, 0, -1, true, lines)
                                end
                              })
                            
                              api.nvim_create_autocmd("BufReadCmd", {
                                group = api.nvim_create_augroup("dap-readcmds", { clear = true }),
                                pattern = "dap-eval://*",
                                callback = function()
                                  local bufnr = api.nvim_get_current_buf()
                                  local fname = api.nvim_buf_get_name(bufnr)
                                  vim.bo[bufnr].swapfile = false
                                  vim.bo[bufnr].buftype = "acwrite"
                                  vim.bo[bufnr].bufhidden = "wipe"
                                  local ft = fname:match("dap%-eval://(%w+)(.*)")
                                  if ft and ft ~= "" then
                                    vim.bo[bufnr].filetype = ft
                                  else
                                    local altbuf = vim.fn.bufnr("#", false)
                                    if altbuf then
                                      vim.bo[bufnr].filetype = vim.bo[altbuf].filetype
                                    end
                                  end
                                  api.nvim_create_autocmd("BufWriteCmd", {
                                    buffer = bufnr,
                                    callback = function(args)
                                      vim.bo[args.buf].modified = false
                                      local repl = require("dap.repl")
                                      local lines = api.nvim_buf_get_lines(args.buf, 0, -1, true)
                                      repl.execute(table.concat(lines, "\n"))
                                      repl.open()
                                    end,
                                  })
                                end,
                              })
                            end

SCRIPT  /Users/anon/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
Sourced 1 time
Total time:   0.003117
 Self time:   0.003117

count  total (s)   self (s)
                            local markview = require("markview");
                            local utils = require("markview.utils");
                            
                            local ts_available, treesitter_parsers = pcall(require, "nvim-treesitter.parsers");
                            local function parser_installed(parser)
                            	return (ts_available and treesitter_parsers.has_parser(parser)) or pcall(vim.treesitter.query.get, parser, "highlights")
                            end
                            
                            -- Check for requirements
                            if vim.fn.has("nvim-0.10") == 0 then
                            	vim.notify("[ markview.nvim ] : This plugin is only available on version 0.10.0 and higher!", vim.log.levels.WARN);
                            	return;
                            elseif not parser_installed("markdown") then
                            	vim.notify("[ markview.nvim ] : Treesitter parser for 'markdown' wasn't found!", vim.log.levels.WARN);
                            	return;
                            elseif not parser_installed("markdown_inline") then
                            	vim.notify("[ markview.nvim ] : Treesitter parser for 'markdown_inline' wasn't found!", vim.log.levels.WARN);
                            	return;
                            elseif not parser_installed("html") then
                            	vim.notify("[ markview.nvim ] : Treesitter parser for 'html' wasn't found! It is required for basic html tag support.", vim.log.levels.WARN);
                            	return;
                            end
                            
                            
                            if markview.configuration.highlight_groups then
                            	markview.add_hls(markview.configuration.highlight_groups)
                            end
                            
                            local buf_render = function (buffer)
                            	local lines = vim.api.nvim_buf_line_count(buffer);
                            	local parsed_content;
                            
                            	local mode = vim.api.nvim_get_mode().mode;
                            
                            	if lines < (markview.configuration.max_length or 1000) then
                            		-- Buffer isn't too big. Render everything
                            		parsed_content = markview.parser.init(buffer, markview.configuration);
                            
                            		markview.renderer.render(buffer, parsed_content, markview.configuration)
                            	else
                            		-- Buffer is too big, render only parts of it
                            		local cursor = vim.api.nvim_win_get_cursor(0);
                            		local start = math.max(0, cursor[1] - (markview.configuration.render_range or 100));
                            		local stop = math.min(lines, cursor[1] + (markview.configuration.render_range or 100));
                            
                            		parsed_content = markview.parser.parse_range(buffer, markview.configuration, start, stop);
                            
                            		markview.renderer.render(buffer, parsed_content, markview.configuration)
                            	end
                            
                            	markview.keymaps.init(buffer, parsed_content, markview.configuration);
                            
                            	-- Don't do hybrid mode stuff unless needed
                            	if not markview.configuration.hybrid_modes or not vim.list_contains(markview.configuration.hybrid_modes, mode) then
                            		return;
                            	elseif markview.state.hybrid_mode == false then
                            		return;
                            	end
                            
                            	local win = utils.find_attached_wins(buffer)[1];
                            
                            	-- Get the cursor
                            	local cursor = vim.api.nvim_win_get_cursor(win or 0);
                            
                            	-- Range to start & stop parsing
                            	local start = math.max(0, cursor[1] - 1);
                            	local stop = math.min(lines, cursor[1]);
                            
                            	-- Get the contents range to clear
                            	local under_cursor = markview.parser.parse_range(buffer, markview.configuration, start, stop);
                            	local clear_range = markview.renderer.get_content_range(under_cursor);
                            
                            	-- Content range was invalid, nothing to clear
                            	if not clear_range or not clear_range[1] or not clear_range[2] then
                            		return;
                            	end
                            
                            	markview.renderer.clear(buffer, clear_range[1], clear_range[2])
                            end
                            
                            
                            
                            local redraw_autocmd = function (augroup, buffer)
                            	local update_events = { "BufEnter", "ModeChanged", "TextChanged" };
                            
                            	if vim.list_contains(markview.configuration.modes, "n") or vim.list_contains(markview.configuration.modes, "v") then
                            		table.insert(update_events, "CursorMoved");
                            	end
                            
                            	if vim.list_contains(markview.configuration.modes, "i") then
                            		table.insert(update_events, "CursorMovedI");
                            		table.insert(update_events, "TextChangedI"); -- For smoother experience when writing, potentially can cause bugs
                            	end
                            
                            	-- Mode
                            	local cached_mode = vim.api.nvim_get_mode().mode;
                            	local timer = vim.uv.new_timer();
                            
                            	-- This is just a cache
                            	local r_autocmd;
                            
                            	local tmp = vim.api.nvim_create_autocmd(update_events, {
                            		buffer = buffer,
                            		group = augroup,
                            		callback = function (event)
                            			local windows = utils.find_attached_wins(buffer);
                            			local debounce = markview.configuration.debounce or 50;
                            
                            			-- Current mode
                            			local mode = vim.api.nvim_get_mode().mode;
                            
                            			if event.event == "ModeChanged" and cached_mode == mode then
                            				debounce = 0;
                            			end
                            
                            			timer:stop();
                            			timer:start(debounce, 0, vim.schedule_wrap(function ()
                            				if markview.state.enable == false or markview.state.buf_states[buffer] == false then
                            					return;
                            				end
                            
                            				--- Incorrect file type
                            				if not vim.list_contains(markview.configuration.filetypes or { "markdown" }, vim.bo[buffer].filetype) then
                            					markview.unload();
                            					vim.api.nvim_del_autocmd(r_autocmd);
                            
                            					return;
                            				end
                            
                            				-- Incorrect buffer type
                            				if vim.islist(markview.configuration.buf_ignore) and vim.list_contains(markview.configuration.buf_ignore, vim.bo[buffer].buftype) then
                            					markview.unload();
                            					vim.api.nvim_del_autocmd(r_autocmd);
                            
                            					return
                            				end
                            
                            
                            				-- Only on mode change or if the mode changed due to text changed
                            				if mode ~= cached_mode or event.event == "ModeChanged" then
                            					-- Call the on_mode_change callback before exiting
                            					if not markview.configuration.callbacks or not markview.configuration.callbacks.on_mode_change then
                            						goto noCallbacks;
                            					end
                            
                            					for _, window in ipairs(windows) do
                            						pcall(markview.configuration.callbacks.on_mode_change, buffer, window, mode);
                            					end
                            				end
                            
                            				::noCallbacks::
                            
                            				cached_mode = mode; -- Still gotta update the cache
                            
                            				if vim.list_contains(markview.configuration.modes, mode) then
                            					markview.renderer.clear(buffer);
                            					buf_render(buffer);
                            				else
                            					markview.renderer.clear(buffer);
                            					vim.cmd("redraw!");
                            				end
                            			end));
                            		end
                            	});
                            
                            	r_autocmd = tmp;
                            end
                            
                            vim.api.nvim_create_autocmd({ "BufWinEnter" }, {
                            	desc = "Attaches markview to the buffers",
                            	callback = function (event)
                            		local buffer = event.buf;
                            
                            		local ft = vim.bo[buffer].filetype;
                            		local bt = vim.bo[buffer].buftype;
                            
                            		--- Incorrect file type
                            		if not vim.list_contains(markview.configuration.filetypes or { "markdown" }, ft) then
                            			return;
                            		end
                            
                            		-- Incorrect buffer type
                            		if vim.islist(markview.configuration.buf_ignore) and vim.list_contains(markview.configuration.buf_ignore, bt) then
                            			return
                            		end
                            
                            		local windows = utils.find_attached_wins(buffer);
                            
                            		-- If not attached then attach
                            		if not vim.list_contains(markview.attached_buffers, buffer) then
                            			table.insert(markview.attached_buffers, buffer);
                            			markview.attached_windows = vim.list_extend(markview.attached_windows, windows);
                            		end
                            
                            		-- Plugin is disabled
                            		if markview.state.enable == false or markview.state.buf_states[buffer] == false then
                            			-- Call the on_disable callback before exiting
                            			if not markview.configuration.callbacks or not markview.configuration.callbacks.on_disable then
                            				return;
                            			end
                            
                            			for _, window in ipairs(windows) do
                            				pcall(markview.configuration.callbacks.on_disable, buffer, window);
                            			end
                            
                            			return;
                            		end
                            
                            		-- Set state to true and call the callback
                            		markview.state.buf_states[buffer] = true;
                            
                            		for _, window in ipairs(windows) do
                            			if markview.configuration.callbacks and markview.configuration.callbacks.on_enable then
                            				pcall(markview.configuration.callbacks.on_enable, buffer, window);
                            			end
                            		end
                            
                            		-- Clear the buffer before rendering things
                            		markview.renderer.clear(buffer);
                            		buf_render(buffer);
                            
                            		-- Augroup for the special autocmds
                            		local markview_augroup = vim.api.nvim_create_augroup("markview_buf_" .. buffer, { clear = true });
                            
                            		redraw_autocmd(markview_augroup, buffer);
                            	end
                            })
                            
                            

SCRIPT  /Users/anon/.local/share/nvim/lazy/diffview.nvim/plugin/diffview.lua
Sourced 1 time
Total time:   0.002014
 Self time:   0.002014

count  total (s)   self (s)
                            if vim.g.diffview_nvim_loaded or not require("diffview.bootstrap") then
                              return
                            end
                            
                            vim.g.diffview_nvim_loaded = 1
                            
                            local lazy = require("diffview.lazy")
                            
                            ---@module "diffview"
                            local arg_parser = lazy.require("diffview.arg_parser") ---@module "diffview.arg_parser"
                            local diffview = lazy.require("diffview") ---@module "diffview"
                            
                            local api = vim.api
                            local command = api.nvim_create_user_command
                            
                            -- NOTE: Need this wrapper around the completion function becuase it doesn't
                            -- exist yet.
                            local function completion(...)
                              return diffview.completion(...)
                            end
                            
                            -- Create commands
                            command("DiffviewOpen", function(ctx)
                              diffview.open(arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion })
                            
                            command("DiffviewFileHistory", function(ctx)
                              local range
                            
                              if ctx.range > 0 then
                                range = { ctx.line1, ctx.line2 }
                              end
                            
                              diffview.file_history(range, arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion, range = true })
                            
                            command("DiffviewClose", function()
                              diffview.close()
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewFocusFiles", function()
                              diffview.emit("focus_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewToggleFiles", function()
                              diffview.emit("toggle_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewRefresh", function()
                              diffview.emit("refresh_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewLog", function()
                              vim.cmd(("sp %s | norm! G"):format(
                                vim.fn.fnameescape(DiffviewGlobal.logger.outfile)
                              ))
                            end, { nargs = 0, bang = true })

SCRIPT  /Users/anon/.local/share/nvim/lazy/neogit/plugin/neogit.lua
Sourced 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                            local api = vim.api
                            
                            api.nvim_create_user_command("Neogit", function(o)
                              local neogit = require("neogit")
                              neogit.open(require("neogit.lib.util").parse_command_args(o.fargs))
                            end, {
                              nargs = "*",
                              desc = "Open Neogit",
                              complete = function(arglead)
                                local neogit = require("neogit")
                                return neogit.complete(arglead)
                              end,
                            })
                            
                            api.nvim_create_user_command("NeogitResetState", function()
                              require("neogit.lib.state")._reset()
                            end, { nargs = "*", desc = "Reset any saved flags" })

SCRIPT  /Users/anon/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
Sourced 1 time
Total time:   0.000625
 Self time:   0.000625

count  total (s)   self (s)
                            vim.api.nvim_create_autocmd({ 'VimEnter' }, {
                              callback = require('mason-tool-installer').run_on_start,
                            })
                            vim.api.nvim_create_user_command('MasonToolsUpdate', function()
                              require('mason-tool-installer').check_install(true)
                            end, { force = true })
                            vim.api.nvim_create_user_command('MasonToolsUpdateSync', function()
                              require('mason-tool-installer').check_install(true, true)
                            end, { force = true })
                            vim.api.nvim_create_user_command('MasonToolsInstall', function()
                              require('mason-tool-installer').check_install(false)
                            end, { force = true })
                            vim.api.nvim_create_user_command('MasonToolsInstallSync', function()
                              require('mason-tool-installer').check_install(false, true)
                            end, { force = true })
                            vim.api.nvim_create_user_command('MasonToolsClean', function()
                              require('mason-tool-installer').clean()
                            end, { force = true })

SCRIPT  /Users/anon/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
Sourced 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000004 command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
    1              0.000002 command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
    1              0.000002 command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
    1              0.000002 command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
    1              0.000002 command! -nargs=* TodoTrouble Trouble todo <args>

SCRIPT  /Users/anon/.local/share/nvim/lazy/vim-glsl/ftdetect/glsl.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            " Language: OpenGL Shading Language
                            " Maintainer: Sergii Tykhomyrov <sergii@tykhomyrov.net>
                            
                            " Extensions supported by Khronos reference compiler (with one exception, ".glsl")
                            " https://github.com/KhronosGroup/glslang
    1              0.000015 autocmd! BufNewFile,BufRead *.vert,*.tesc,*.tese,*.glsl,*.geom,*.frag,*.comp,*.rgen,*.rmiss,*.rchit,*.rahit,*.rint,*.rcall set filetype=glsl
                            
                            " vim:set sts=2 sw=2 :

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/editorconfig.lua
Sourced 1 time
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
                            local group = vim.api.nvim_create_augroup('editorconfig', {})
                            vim.api.nvim_create_autocmd({ 'BufNewFile', 'BufRead', 'BufFilePost' }, {
                              group = group,
                              callback = function(args)
                                -- Buffer-local enable has higher priority
                                local enable = vim.F.if_nil(vim.b.editorconfig, vim.g.editorconfig, true)
                                if not enable then
                                  return
                                end
                            
                                require('editorconfig').config(args.buf)
                              end,
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000005 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000000 endif
    1              0.000001 let loaded_gzip = 1
                            
    1              0.000000 augroup gzip
                              " Remove all gzip autocommands
    1              0.000002   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000008   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000002   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000001   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000001   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000001   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000001   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000001   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000001   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000001   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000001   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000001   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000001   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000001   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000001   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000001   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000001   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000001   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000001   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000001   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000001   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000001   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000001   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000001 augroup END

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/man.lua
Sourced 1 time
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
                            if vim.g.loaded_man ~= nil then
                              return
                            end
                            vim.g.loaded_man = true
                            
                            vim.api.nvim_create_user_command('Man', function(params)
                              local man = require('man')
                              if params.bang then
                                man.init_pager()
                              else
                                local ok, err = pcall(man.open_page, params.count, params.smods, params.fargs)
                                if not ok then
                                  vim.notify(man.errormsg or err, vim.log.levels.ERROR)
                                end
                              end
                            end, {
                              bang = true,
                              bar = true,
                              range = true,
                              addr = 'other',
                              nargs = '*',
                              complete = function(...)
                                return require('man').man_complete(...)
                              end,
                            })
                            
                            local augroup = vim.api.nvim_create_augroup('man', {})
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = augroup,
                              pattern = 'man://*',
                              nested = true,
                              callback = function(params)
                                require('man').read_page(vim.fn.matchstr(params.match, 'man://\\zs.*'))
                              end,
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.000694
 Self time:   0.000604

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000003 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
    1   0.000674   0.000585   packadd matchit
    1              0.000001 endif

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 1 time
Total time:   0.000086
 Self time:   0.000041

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Maintainer:  Christian Brabandt
                            "  Version:     1.19
                            "  Last Change: 2023, June 28th
                            "  Repository:  https://github.com/chrisbra/matchit
                            "  Previous URL:http://www.vim.org/script.php?script_id=39
                            "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            
                            " Documentation:
                            "  The documentation is in a separate file: ../doc/matchit.txt
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " Allow user to prevent loading and prevent duplicate loading.
    1              0.000001 if exists("g:loaded_matchit") || &cp
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_matchit = 1
                            
    1              0.000001 let s:save_cpo = &cpo
    1              0.000002 set cpo&vim
                            
    1              0.000001 fun MatchEnable()
                              nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
                              nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
                              xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>
                                    \:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
                              xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
                              onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
                              onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
                              " Analogues of [{ and ]} using matching patterns:
                              nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
                              nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
                              xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
                              xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
                              onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
                              onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
                              " text object:
                              xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
                            
                              if !exists("g:no_plugin_maps")
                                nmap <silent> %  <Plug>(MatchitNormalForward)
                                nmap <silent> g% <Plug>(MatchitNormalBackward)
                                xmap <silent> %  <Plug>(MatchitVisualForward)
                                xmap <silent> g% <Plug>(MatchitVisualBackward)
                                omap <silent> %  <Plug>(MatchitOperationForward)
                                omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                                " Analogues of [{ and ]} using matching patterns:
                                nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
                                nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
                                xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
                                xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
                                omap <silent> [% <Plug>(MatchitOperationMultiBackward)
                                omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                                " Text object
                                xmap a% <Plug>(MatchitVisualTextObject)
                              endif
                            endfun
                            
    1              0.000000 fun MatchDisable()
                              " remove all the setup keymappings
                              nunmap %
                              nunmap g%
                              xunmap %
                              xunmap g%
                              ounmap %
                              ounmap g%
                            
                              nunmap [%
                              nunmap ]%
                              xunmap [%
                              xunmap ]%
                              ounmap [%
                              ounmap ]%
                            
                              xunmap a%
                            endfun
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000002 if !exists(":MatchDebug")
    1              0.000002   command! -nargs=0 MatchDebug call matchit#Match_debug()
    1              0.000000 endif
    1              0.000001 if !exists(":MatchDisable")
    1              0.000001   command! -nargs=0 MatchDisable :call MatchDisable()
    1              0.000000 endif
    1              0.000001 if !exists(":MatchEnable")
    1              0.000001   command! -nargs=0 MatchEnable :call MatchEnable()
    1              0.000000 endif
                            
    1   0.000048   0.000003 call MatchEnable()
                            
    1              0.000001 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2024 May 18
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
    1              0.000001 if exists("g:loaded_matchparen") || &cp
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_matchparen = 1
                            
    1              0.000001 if !exists("g:matchparen_timeout")
    1              0.000001   let g:matchparen_timeout = 300
    1              0.000000 endif
    1              0.000001 if !exists("g:matchparen_insert_timeout")
    1              0.000001   let g:matchparen_insert_timeout = 60
    1              0.000000 endif
                            
    1              0.000001 let s:has_matchaddpos = exists('*matchaddpos')
                            
    1              0.000000 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000003   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000001   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
    1              0.000001   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
    1              0.000001   if exists('##TextChanged')
    1              0.000002     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001     autocmd! TextChangedP * call s:Remove_Matches()
    1              0.000000   endif
    1              0.000000 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000001 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000000 endif
                            
    1              0.000001 let s:cpo_save = &cpo
    1              0.000001 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000001 func s:Highlight_Matching_Pair()
                              if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
                              endif
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))'
                                    \ . '->indexof({_, id -> synIDattr(id, "name") =~? '
                                    \ . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000000 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000001 command DoMatchParen call s:DoMatchParen()
    1              0.000013 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000000 func s:NoMatchParen()
                              let w = winnr()
                              noau windo call s:Remove_Matches()
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000000 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000001 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Date:		Feb 09, 2021
                            " Last Change:
                            "   2024 May 08 by Vim Project: cleanup legacy Win9X checks
                            " Former Maintainer:   Charles E Campbell
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000001 if &cp || exists("g:loaded_netrwPlugin")
    1              0.000001  finish
                            endif
                            let g:loaded_netrwPlugin = "v173"
                            let s:keepcpo = &cpo
                            set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
                            augroup FileExplorer
                             au!
                             au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
                             au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
                             au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
                             if has("win32")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
                             endif
                            augroup END
                            
                            " Network Browsing Reading Writing: {{{2
                            augroup Network
                             au!
                             au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
                             au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
                             au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
                             au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
                             au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
                             try
                              au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
                            augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
                            com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
                            com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
                            com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
                            com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
                            com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
                            com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
                            com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
                            com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
                            com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
                            com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
                            if !exists("g:netrw_nogx")
                             if maparg('gx','n') == ""
                              if !hasmapto('<Plug>NetrwBrowseX')
                               nmap <unique> gx <Plug>NetrwBrowseX
                              endif
                              nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
                             endif
                             if maparg('gx','x') == ""
                              if !hasmapto('<Plug>NetrwBrowseXVis')
                               xmap <unique> gx <Plug>NetrwBrowseXVis
                              endif
                              xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
                             endif
                            endif
                            if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
                            fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
                            fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
                            fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
                            fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
                            let &cpo= s:keepcpo
                            unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/osc52.lua
Sourced 1 time
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
                            local tty = false
                            for _, ui in ipairs(vim.api.nvim_list_uis()) do
                              if ui.chan == 1 and ui.stdout_tty then
                                tty = true
                                break
                              end
                            end
                            
                            if not tty or vim.g.clipboard ~= nil or vim.o.clipboard ~= '' or not os.getenv('SSH_TTY') then
                              return
                            end
                            
                            require('vim.termcap').query('Ms', function(cap, found, seq)
                              if not found then
                                return
                              end
                            
                              assert(cap == 'Ms')
                            
                              -- Check 'clipboard' and g:clipboard again to avoid a race condition
                              if vim.o.clipboard ~= '' or vim.g.clipboard ~= nil then
                                return
                              end
                            
                              -- If the terminal reports a sequence other than OSC 52 for the Ms capability
                              -- then ignore it. We only support OSC 52 (for now)
                              if not seq or not seq:match('^\027%]52') then
                                return
                              end
                            
                              local osc52 = require('vim.ui.clipboard.osc52')
                            
                              vim.g.clipboard = {
                                name = 'OSC 52',
                                copy = {
                                  ['+'] = osc52.copy('+'),
                                  ['*'] = osc52.copy('*'),
                                },
                                paste = {
                                  ['+'] = osc52.paste('+'),
                                  ['*'] = osc52.paste('*'),
                                },
                              }
                            end)

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000083
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000001 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000000 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000000 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000000 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000002 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1              0.000002 if index(v:argv, "--clean") < 0
    1   0.000062   0.000003   call s:LoadRemotePlugins()
    1              0.000001 endif

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_shada_plugin = 1
                            
    1              0.000000 augroup ShaDaCommands
    1              0.000002   autocmd!
    1              0.000004   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000003   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000003   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000003   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000003   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000002   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000001 augroup END

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000002 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000000 endif
    1              0.000001 let loaded_spellfile_plugin = 1
                            
    1              0.000002 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000001 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000000 endif
    1              0.000001 let g:loaded_tarPlugin = "v32"
    1              0.000001 let s:keepcpo          = &cpo
    1              0.000001 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000000 augroup tar
    1              0.000001   au!
    1              0.000001   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000001   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000001   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000001   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000001   if has("unix")
    1              0.000002    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000001    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000001    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000000   endif
                            
    1              0.000001   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tzst			call tar#Browse(expand("<amatch>"))
    1              0.000000 augroup END
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000001 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/tohtml.lua
Sourced 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                            if vim.g.loaded_2html_plugin ~= nil then
                              return
                            end
                            vim.g.loaded_2html_plugin = true
                            
                            vim.api.nvim_create_user_command('TOhtml', function(args)
                              local outfile = args.args ~= '' and args.args or vim.fn.tempname() .. '.html'
                              local html = require('tohtml').tohtml(0, { range = { args.line1, args.line2 } })
                              vim.fn.writefile(html, outfile)
                              vim.cmd.split(outfile)
                              vim.bo.filetype = 'html'
                            end, { bar = true, nargs = '?', range = '%' })

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000000 endif
    1              0.000001 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000003 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Dec 07, 2021
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Former Maintainer:	Charles E Campbell
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000001 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000000 endif
    1              0.000000 let g:loaded_zipPlugin = "v33"
    1              0.000000 let s:keepcpo          = &cpo
    1              0.000001 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000001 if !exists("g:zipPlugin_ext")
    1              0.000002  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000000 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000000 augroup zip
    1              0.000001  au!
    1              0.000001  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000001  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000001  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000001  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000000  if has("unix")
    1              0.000001   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000001   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000001   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000000  endif
                            
    1              0.000020  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000000 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000001 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo

SCRIPT  /Users/anon/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
Sourced 1 time
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
                            require('cmp').register_source('path', require('cmp_path').new())

SCRIPT  /Users/anon/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
Sourced 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                            require('cmp_nvim_lsp').setup()

SCRIPT  /Users/anon/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua
Sourced 1 time
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
                            require("cmp").register_source("luasnip", require("cmp_luasnip").new())
                            
                            local cmp_luasnip = vim.api.nvim_create_augroup("cmp_luasnip", {})
                            
                            vim.api.nvim_create_autocmd("User", {
                              pattern = "LuasnipCleanup",
                              callback = function ()
                                require("cmp_luasnip").clear_cache()
                              end,
                              group = cmp_luasnip
                            })
                            
                            vim.api.nvim_create_autocmd("User", {
                              pattern = "LuasnipSnippetsAdded",
                              callback = function ()
                                require("cmp_luasnip").refresh()
                              end,
                              group = cmp_luasnip
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000289
 Self time:   0.000213

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000001 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000001 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000000 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000198   0.000171 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000001 if exists("did_load_filetypes")
    1              0.000000   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000000 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000000 augroup syntaxset
    1              0.000001   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000000 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000076   0.000028 doautoall syntaxset FileType
    1              0.000000 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000001 endif

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000001 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " let others know that syntax has been switched on
    1              0.000001 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000001 let s:cpo_save = &cpo
    1              0.000001 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000001 au! Syntax
                            
    1              0.000001 au Syntax *		call s:SynSet()
                            
    1              0.000001 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000004 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000001 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000000 endif
                            
                            " Restore 'cpoptions'
    1              0.000001 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save

SCRIPT  /Users/anon/.local/share/nvim/lazy/ccc.nvim/plugin/ccc.vim
Sourced 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000001 if exists('g:loaded_ccc')
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_ccc = 1
                            
    1              0.000002 highlight default link CccFloatNormal NormalFloat
    1              0.000001 highlight default link CccFloatBorder FloatBorder

SCRIPT  /Users/anon/.local/share/nvim/lazy/dashboard-nvim/plugin/dashboard.lua
Sourced 1 time
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
                            -- version 0.2.3
                            
                            local g = vim.api.nvim_create_augroup('dashboard', { clear = true })
                            
                            vim.api.nvim_create_autocmd('StdinReadPre', {
                              group = g,
                              callback = function()
                                vim.g.read_from_stdin = 1
                              end,
                            })
                            
                            vim.api.nvim_create_autocmd('UIEnter', {
                              group = g,
                              callback = function()
                                if
                                  vim.fn.argc() == 0
                                  and vim.api.nvim_buf_get_name(0) == ''
                                  and vim.g.read_from_stdin == nil
                                then
                                  require('dashboard'):instance()
                                end
                              end,
                            })
                            
                            vim.api.nvim_create_user_command('Dashboard', function()
                              require('dashboard'):instance()
                            end, {})

SCRIPT  /Users/anon/.local/share/nvim/lazy/oil.nvim/syntax/oil.vim
Sourced 4 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
    4              0.000011 if exists("b:current_syntax")
                              finish
    4              0.000002 endif
                            
    4              0.000016 syn match oilId /^\/\d* / conceal
                            
    4              0.000010 let b:current_syntax = "oil"

SCRIPT  /Users/anon/.local/share/nvim/lazy/grapple.nvim/plugin/grapple.lua
Sourced 1 time
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
                            ---Initialize Grapple. Sets up autocommands to watch tagged files and creates the
                            
                            ---"Grapple" user command. Called only once when plugin is loaded.
                            -- Create highlights for Grapple windows
                            vim.cmd("highlight default GrappleBold gui=bold cterm=bold")
                            vim.cmd("highlight default link GrappleHint Comment")
                            vim.cmd("highlight default link GrappleName DiagnosticHint")
                            vim.cmd("highlight default link GrappleNoExist DiagnosticError")
                            vim.cmd("highlight default link GrappleNormal NormalFloat")
                            vim.cmd("highlight default link GrappleBorder FloatBorder")
                            vim.cmd("highlight default link GrappleTitle FloatTitle")
                            vim.cmd("highlight default link GrappleFooter FloatFooter")
                            
                            vim.cmd("highlight default GrappleCurrent gui=bold cterm=bold")
                            vim.cmd("highlight! link GrappleCurrent SpecialChar")
                            
                            -- Create autocommand to keep Grapple state up-to-date
                            vim.api.nvim_create_augroup("Grapple", { clear = true })
                            vim.api.nvim_create_autocmd({ "BufWinLeave", "QuitPre" }, {
                                pattern = "?*", -- non-empty file
                                group = "Grapple",
                                callback = function(opts)
                                    require("grapple").touch({ buffer = opts.buf })
                                end,
                            })
                            
                            -- Create top-level user command. Basically a wrapper around the lua API
                            vim.api.nvim_create_user_command(
                                "Grapple",
                            
                                ---@param opts grapple.vim.user_command
                                function(opts)
                                    local Grapple = require("grapple")
                            
                                    local action = opts.fargs[1] or "toggle"
                                    local args = {}
                                    local kwargs = {}
                            
                                    for _, arg in ipairs({ unpack(opts.fargs, 2) }) do
                                        local key, value = string.match(arg, "^(.*)=(.*)$")
                            
                                        if value == "" then
                                            value = nil
                                        end
                            
                                        if not key then
                                            table.insert(args, tonumber(arg) or arg)
                                        else
                                            kwargs[key] = tonumber(value) or value
                                        end
                                    end
                            
                                    if not Grapple[action] then
                                        return vim.notify(string.format("invalid action: %s", action), vim.log.levels.WARN)
                                    end
                            
                                    if #args > 0 and not vim.tbl_isempty(kwargs) then
                                        Grapple[action](unpack(args), kwargs)
                                    elseif #args > 0 and vim.tbl_isempty(kwargs) then
                                        Grapple[action](unpack(args))
                                    elseif #args == 0 and not vim.tbl_isempty(kwargs) then
                                        Grapple[action](kwargs)
                                    else
                                        Grapple[action]()
                                    end
                                end,
                                {
                                    desc = "Grapple",
                                    nargs = "*",
                                    complete = function(current, command, _)
                                        local Grapple = require("grapple")
                                        local Util = require("grapple.util")
                            
                                        local app = Grapple.app()
                            
                                        -- Keyword argument names permitted by Grapple
                                        -- "tag" kwargs refer to methods that accept all keyword arguments (i.e. toggle)
                                        -- "new" kwargs refer to methods that create a new tag (i.e. tag)
                                        -- "use" kwargs refer to methods that use an existing tag (i.e. select)
                                        -- "scope" kwargs refer to methods that operate on a scope (i.e. quickfix)
                                        -- "window" kwargs refer to methods that open a window (i.e. toggle_tags)
                                        local tag_kwargs = { "buffer", "path", "name", "index", "scope", "command" }
                                        local new_kwargs = Util.subtract(tag_kwargs, { "command" })
                                        local use_kwargs = Util.subtract(tag_kwargs, { "command" })
                                        local scope_kwargs = { "scope", "id" }
                                        local window_kwargs = { "style", unpack(scope_kwargs) }
                            
                                        -- stylua: ignore
                                        -- Lookup table of API functions and their available arguments
                                        local subcommand_lookup = {
                                            clear_cache    = { args = { "scope" },     kwargs = {} },
                                            cycle_tags     = { args = { "direction" }, kwargs = use_kwargs },
                                            cycle_scopes   = { args = { "direction" }, kwargs = { "scope", "all" } },
                                            open_loaded    = { args = {},              kwargs = { "all" } },
                                            open_scopes    = { args = {},              kwargs = {} },
                                            open_tags      = { args = {},              kwargs = window_kwargs },
                                            prune          = { args = {},              kwargs = { "limit" } },
                                            quickfix       = { args = {},              kwargs = scope_kwargs },
                                            reset          = { args = {},              kwargs = scope_kwargs },
                                            select         = { args = {},              kwargs = use_kwargs },
                                            tag            = { args = {},              kwargs = new_kwargs },
                                            toggle         = { args = {},              kwargs = tag_kwargs },
                                            toggle_loaded  = { args = {},              kwargs = { "all" } },
                                            toggle_scopes  = { args = {},              kwargs = { "all" } },
                                            toggle_tags    = { args = {},              kwargs = window_kwargs },
                                            unload         = { args = {},              kwargs = scope_kwargs },
                                            untag          = { args = {},              kwargs = use_kwargs },
                                            use_scope      = { args = { "scope" },     kwargs = {} },
                                        }
                            
                                        -- Lookup table of arguments and their known values
                                        local argument_lookup = {
                                            all = { "true", "false" },
                                            direction = { "next", "prev" },
                                            scope = vim.tbl_map(Util.pick("name"), app:list_scopes()),
                                            style = Util.sort(vim.tbl_keys(app.settings.styles), Util.as_lower),
                                        }
                            
                                        -- API methods which are not actionable
                                        local excluded_subcmds = {
                                            -- Deprecated
                                            "cycle",
                                            "cycle_backward",
                                            "cycle_forward",
                            
                                            "app",
                                            "define_scope",
                                            "delete_scope",
                                            "exists",
                                            "find",
                                            "name_or_index",
                                            "setup",
                                            "statusline",
                                            "tags",
                                            "touch",
                                        }
                            
                                        -- Grab all actionable subcommands made available by Grapple
                                        local subcmds = vim.tbl_keys(Grapple)
                                        subcmds = Util.subtract(subcmds, excluded_subcmds)
                                        table.sort(subcmds, Util.as_lower)
                            
                                        local check = vim.tbl_keys(subcommand_lookup)
                                        check = Util.subtract(check, excluded_subcmds)
                                        table.sort(check, Util.as_lower)
                            
                                        -- Ensure we aren't missing in the lookup table above
                                        if not Util.same(subcmds, check) then
                                            local missing = Util.add(Util.subtract(subcmds, check), Util.subtract(check, subcmds))
                                            error(string.format("missing lookup for subcommands: %s", table.concat(missing, ", ")))
                                        end
                            
                                        -- Time to start processing the command
                                        local input = vim.split(command, "%s+")
                                        local input_subcmd = input[2]
                                        local input_rem = { unpack(input, 3) }
                            
                                        -- "Grapple |"
                                        -- "Grapple sub|"
                            
                                        if #input == 2 then
                                            -- stylua: ignore
                                            return current == ""
                                                and subcmds
                                                or vim.tbl_filter(Util.startswith(current), subcmds)
                                        end
                            
                                        local completion = subcommand_lookup[input_subcmd]
                                        if not completion then
                                            return
                                        end
                            
                                        local input_args = { unpack(input_rem, 1, #completion.args) }
                                        local input_kwargs = { unpack(input_rem, #completion.args + 1) }
                            
                                        -- "Grapple subcmd |"
                                        -- "Grapple subcmd ar|"
                            
                                        if #input_kwargs == 0 then
                                            local arg_name = completion.args[#input_args]
                                            local arg_values = argument_lookup[arg_name] or {}
                            
                                            -- stylua: ignore
                                            return current == ""
                                                and arg_values
                                                or vim.tbl_filter(Util.startswith(current), arg_values)
                                        end
                            
                                        -- "Grapple subcmd arg |"
                                        -- "Grapple subcmd arg k|"
                            
                                        local key, value = string.match(current, "^(.*)=(.*)$")
                                        if not key then
                                            local input_keys = vim.tbl_map(Util.match_key, input_kwargs)
                                            local kwarg_keys = Util.subtract(completion.kwargs, input_keys)
                            
                                            -- stylua: ignore
                                            local filtered = current == ""
                                            and kwarg_keys
                                            or vim.tbl_filter(Util.startswith(current), completion.kwargs)
                            
                                            return vim.tbl_map(Util.with_suffix("="), filtered)
                                        end
                            
                                        -- "Grapple subcmd arg key=|"
                                        -- "Grapple subcmd arg key=val|"
                            
                                        local kwarg_values = argument_lookup[key] or {}
                            
                                            -- stylua: ignore
                                            local filtered = value == ""
                                                and kwarg_values
                                                or vim.tbl_filter(Util.startswith(value), kwarg_values)
                            
                                        return vim.tbl_map(Util.with_prefix(key .. "="), filtered)
                                    end,
                                }
                            )

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/ftplugin/lua.vim
Sourced 2 times
Total time:   0.000471
 Self time:   0.000471

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Tyler Miller <tmillr@proton.me>
                            " Last Change:		2024 Jan 14
                            
    2              0.000011 if exists("b:did_ftplugin")
                              finish
    2              0.000001 endif
    2              0.000005 let b:did_ftplugin = 1
                            
    2              0.000004 let s:cpo_save = &cpo
    2              0.000015 set cpo&vim
                            
    2              0.000007 setlocal comments=:---,:--
    2              0.000005 setlocal commentstring=--\ %s
    2              0.000008 setlocal formatoptions-=t formatoptions+=croql
                            
    2              0.000007 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
                            " TODO: handle init.lua
    2              0.000005 setlocal includeexpr=tr(v:fname,'.','/')
    2              0.000004 setlocal suffixesadd=.lua
                            
    2              0.000003 let b:undo_ftplugin = "setlocal cms< com< def< fo< inex< sua<"
                            
    2              0.000006 if exists("loaded_matchit") && !exists("b:match_words")
    2              0.000003   let b:match_ignorecase = 0
    2              0.000020   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    2              0.000005   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    2              0.000001 endif
                            
    2              0.000012 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    2              0.000001 endif
                            
    2              0.000005 let &cpo = s:cpo_save
    2              0.000003 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/ftplugin/lua.lua
Sourced 2 times
Total time:   0.008628
 Self time:   0.008628

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/indent/lua.vim
Sourced 2 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            
                            " Only load this indent file when no other was loaded.
    2              0.000004 if exists("b:did_indent")
                              finish
    2              0.000001 endif
    2              0.000003 let b:did_indent = 1
                            
    2              0.000007 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    2              0.000005 setlocal indentkeys+=0=end,0=until
                            
    2              0.000003 setlocal autoindent
                            
    2              0.000003 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    2              0.000004 if exists("*GetLuaIndent")
    1              0.000001   finish
    1              0.000001 endif
                            
    1              0.000003 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.000796
 Self time:   0.000796

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    1              0.000003 if exists("b:current_syntax")
                              finish
    1              0.000000 endif
                            
    1              0.000002 let s:cpo_save = &cpo
    1              0.000003 set cpo&vim
                            
    1              0.000001 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000001   let lua_version = 5
    1              0.000001   let lua_subversion = 3
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000000 endif
                            
    1              0.000001 syn case match
                            
                            " syncing method
    1              0.000001 syn sync minlines=1000
                            
    1              0.000001 if lua_version >= 5
    1              0.000004   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    1              0.000001   syn keyword luaMetaMethod __eq __lt __le
    1              0.000001   syn keyword luaMetaMethod __index __newindex __call
    1              0.000011   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    1              0.000001   syn keyword luaMetaMethod __mod __len
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000000   syn keyword luaMetaMethod __pairs
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    1              0.000001   syn keyword luaMetaMethod __idiv __name
    1              0.000001   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    1              0.000000 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    1              0.000006 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    1              0.000001 syn match  luaParenError ")"
    1              0.000001 syn match  luaError "}"
    1              0.000004 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    1              0.000005 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    1              0.000002 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    1              0.000005 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    1              0.000004 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    1              0.000003 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    1              0.000003 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    1              0.000003 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    1              0.000003 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000003 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000001 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    1              0.000001 syn keyword luaStatement return local break
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaStatement goto
    1              0.000001   syn match luaLabel "::\I\i*::"
    1              0.000000 endif
                            
                            " operators
    1              0.000001 syn keyword luaOperator and or not
                            
    1              0.000001 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    1              0.000003   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    1              0.000000 endif
                            
                            " comments
    1              0.000001 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000003 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000002 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000001 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000003   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000000 endif
                            
                            " first line may start with #!
    1              0.000001 syn match luaComment "\%^#!.*"
                            
    1              0.000001 syn keyword luaConstant nil
    1              0.000001 if lua_version > 4
    1              0.000002   syn keyword luaConstant true false
    1              0.000000 endif
                            
                            " strings
    1              0.000005 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    1              0.000000 if lua_version == 5
    1              0.000001   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000000   else
    1              0.000001     if lua_subversion >= 2
    1              0.000008       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 3
    1              0.000003       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    1              0.000000     endif
    1              0.000002     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000000   endif
    1              0.000000 endif
    1              0.000003 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000002 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000001 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000002 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    1              0.000002 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000001 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000000 if lua_version >= 5
    1              0.000000   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000001   elseif lua_subversion >= 2
    1              0.000002     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000000   endif
    1              0.000000 endif
                            
                            " tables
    1              0.000002 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    1              0.000001 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    1              0.000001 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000002 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    1              0.000000 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000000 elseif lua_version == 5
    1              0.000001   syn keyword luaFunc getmetatable setmetatable
    1              0.000000   syn keyword luaFunc ipairs pairs
    1              0.000000   syn keyword luaFunc pcall xpcall
    1              0.000001   syn keyword luaFunc _G loadfile rawequal require
    1              0.000000   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000000   else
    1              0.000001     syn keyword luaFunc load select
    1              0.000002     syn match   luaFunc /\<package\.cpath\>/
    1              0.000001     syn match   luaFunc /\<package\.loaded\>/
    1              0.000001     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000001     syn match   luaFunc /\<package\.path\>/
    1              0.000001     syn match   luaFunc /\<package\.preload\>/
    1              0.000000     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000001     elseif lua_subversion >= 2
    1              0.000001       syn keyword luaFunc _ENV rawlen
    1              0.000001       syn match   luaFunc /\<package\.config\>/
    1              0.000001       syn match   luaFunc /\<package\.preload\>/
    1              0.000002       syn match   luaFunc /\<package\.searchers\>/
    1              0.000001       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000000     endif
                            
    1              0.000000     if lua_subversion >= 3
    1              0.000002       syn match luaFunc /\<coroutine\.isyieldable\>/
    1              0.000000     endif
    1              0.000000     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    1              0.000000     endif
    1              0.000001     syn match luaFunc /\<coroutine\.running\>/
    1              0.000000   endif
    1              0.000001   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000001   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000001   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.yield\>/
                            
    1              0.000001   syn match   luaFunc /\<string\.byte\>/
    1              0.000001   syn match   luaFunc /\<string\.char\>/
    1              0.000001   syn match   luaFunc /\<string\.dump\>/
    1              0.000001   syn match   luaFunc /\<string\.find\>/
    1              0.000001   syn match   luaFunc /\<string\.format\>/
    1              0.000001   syn match   luaFunc /\<string\.gsub\>/
    1              0.000001   syn match   luaFunc /\<string\.len\>/
    1              0.000001   syn match   luaFunc /\<string\.lower\>/
    1              0.000001   syn match   luaFunc /\<string\.rep\>/
    1              0.000001   syn match   luaFunc /\<string\.sub\>/
    1              0.000001   syn match   luaFunc /\<string\.upper\>/
    1              0.000000   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000000   else
    1              0.000001     syn match luaFunc /\<string\.gmatch\>/
    1              0.000001     syn match luaFunc /\<string\.match\>/
    1              0.000001     syn match luaFunc /\<string\.reverse\>/
    1              0.000000   endif
    1              0.000000   if lua_subversion >= 3
    1              0.000001     syn match luaFunc /\<string\.pack\>/
    1              0.000001     syn match luaFunc /\<string\.packsize\>/
    1              0.000001     syn match luaFunc /\<string\.unpack\>/
    1              0.000001     syn match luaFunc /\<utf8\.char\>/
    1              0.000001     syn match luaFunc /\<utf8\.charpattern\>/
    1              0.000001     syn match luaFunc /\<utf8\.codes\>/
    1              0.000001     syn match luaFunc /\<utf8\.codepoint\>/
    1              0.000001     syn match luaFunc /\<utf8\.len\>/
    1              0.000001     syn match luaFunc /\<utf8\.offset\>/
    1              0.000000   endif
                            
    1              0.000000   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000000   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000000   elseif lua_subversion >= 2
    1              0.000001     syn match luaFunc /\<table\.pack\>/
    1              0.000001     syn match luaFunc /\<table\.unpack\>/
    1              0.000000     if lua_subversion >= 3
    1              0.000001       syn match luaFunc /\<table\.move\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   syn match   luaFunc /\<table\.concat\>/
    1              0.000001   syn match   luaFunc /\<table\.insert\>/
    1              0.000001   syn match   luaFunc /\<table\.sort\>/
    1              0.000001   syn match   luaFunc /\<table\.remove\>/
                            
    1              0.000000   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000000   endif
                            
    1              0.000001   syn match   luaFunc /\<math\.abs\>/
    1              0.000001   syn match   luaFunc /\<math\.acos\>/
    1              0.000001   syn match   luaFunc /\<math\.asin\>/
    1              0.000001   syn match   luaFunc /\<math\.atan\>/
    1              0.000000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.ceil\>/
    1              0.000001   syn match   luaFunc /\<math\.sin\>/
    1              0.000001   syn match   luaFunc /\<math\.cos\>/
    1              0.000001   syn match   luaFunc /\<math\.tan\>/
    1              0.000001   syn match   luaFunc /\<math\.deg\>/
    1              0.000001   syn match   luaFunc /\<math\.exp\>/
    1              0.000001   syn match   luaFunc /\<math\.floor\>/
    1              0.000001   syn match   luaFunc /\<math\.log\>/
    1              0.000001   syn match   luaFunc /\<math\.max\>/
    1              0.000001   syn match   luaFunc /\<math\.min\>/
    1              0.000000   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000000   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    1              0.000000   endif
    1              0.000000   if lua_subversion >= 1
    1              0.000001     syn match luaFunc /\<math\.huge\>/
    1              0.000002     syn match luaFunc /\<math\.fmod\>/
    1              0.000001     syn match luaFunc /\<math\.modf\>/
    1              0.000001     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   syn match   luaFunc /\<math\.rad\>/
    1              0.000001   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    1              0.000000   else
    1              0.000001     syn match   luaFunc /\<math\.maxinteger\>/
    1              0.000001     syn match   luaFunc /\<math\.mininteger\>/
    1              0.000001     syn match   luaFunc /\<math\.tointeger\>/
    1              0.000001     syn match   luaFunc /\<math\.type\>/
    1              0.000001     syn match   luaFunc /\<math\.ult\>/
    1              0.000000   endif
    1              0.000001   syn match   luaFunc /\<math\.random\>/
    1              0.000001   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000003   syn match   luaFunc /\<math\.pi\>/
                            
    1              0.000001   syn match   luaFunc /\<io\.close\>/
    1              0.000001   syn match   luaFunc /\<io\.flush\>/
    1              0.000001   syn match   luaFunc /\<io\.input\>/
    1              0.000001   syn match   luaFunc /\<io\.lines\>/
    1              0.000001   syn match   luaFunc /\<io\.open\>/
    1              0.000001   syn match   luaFunc /\<io\.output\>/
    1              0.000001   syn match   luaFunc /\<io\.popen\>/
    1              0.000001   syn match   luaFunc /\<io\.read\>/
    1              0.000001   syn match   luaFunc /\<io\.stderr\>/
    1              0.000001   syn match   luaFunc /\<io\.stdin\>/
    1              0.000001   syn match   luaFunc /\<io\.stdout\>/
    1              0.000001   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000001   syn match   luaFunc /\<io\.type\>/
    1              0.000001   syn match   luaFunc /\<io\.write\>/
                            
    1              0.000001   syn match   luaFunc /\<os\.clock\>/
    1              0.000001   syn match   luaFunc /\<os\.date\>/
    1              0.000001   syn match   luaFunc /\<os\.difftime\>/
    1              0.000001   syn match   luaFunc /\<os\.execute\>/
    1              0.000001   syn match   luaFunc /\<os\.exit\>/
    1              0.000001   syn match   luaFunc /\<os\.getenv\>/
    1              0.000001   syn match   luaFunc /\<os\.remove\>/
    1              0.000001   syn match   luaFunc /\<os\.rename\>/
    1              0.000001   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000001   syn match   luaFunc /\<os\.time\>/
    1              0.000001   syn match   luaFunc /\<os\.tmpname\>/
                            
    1              0.000002   syn match   luaFunc /\<debug\.debug\>/
    1              0.000001   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000001   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000001   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000001   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000001   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000001   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000001   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000001   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000001   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    1              0.000000   endif
    1              0.000000   if lua_subversion >= 1
    1              0.000001     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000001     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000001     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000000     if lua_subversion >= 2
    1              0.000001       syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000002       syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000001       syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000001       syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000000     endif
    1              0.000000     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000000 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000002 hi def link luaStatement        Statement
    1              0.000001 hi def link luaRepeat           Repeat
    1              0.000001 hi def link luaFor              Repeat
    1              0.000001 hi def link luaString           String
    1              0.000000 hi def link luaString2          String
    1              0.000001 hi def link luaStringDelimiter  luaString
    1              0.000000 hi def link luaNumber           Number
    1              0.000001 hi def link luaOperator         Operator
    1              0.000001 hi def link luaSymbolOperator   luaOperator
    1              0.000001 hi def link luaConstant         Constant
    1              0.000001 hi def link luaCond             Conditional
    1              0.000001 hi def link luaCondElse         Conditional
    1              0.000000 hi def link luaFunction         Function
    1              0.000000 hi def link luaMetaMethod       Function
    1              0.000001 hi def link luaComment          Comment
    1              0.000001 hi def link luaCommentDelimiter luaComment
    1              0.000001 hi def link luaTodo             Todo
    1              0.000001 hi def link luaTable            Structure
    1              0.000001 hi def link luaError            Error
    1              0.000000 hi def link luaParenError       Error
    1              0.000001 hi def link luaSpecial          SpecialChar
    1              0.000000 hi def link luaFunc             Identifier
    1              0.000000 hi def link luaLabel            Label
                            
                            
    1              0.000001 let b:current_syntax = "lua"
                            
    1              0.000002 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            " vim: et ts=8 sw=2

FUNCTION  <SNR>26_DetectDeclared()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:488
Called 3 times
Total time:   0.009028
 Self time:   0.000199

count  total (s)   self (s)
    3   0.000035   0.000030   let detected = {'bufname': s:Slash(@%), 'declared': {}}
    3              0.000016   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
    3              0.000009   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
                                let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
                                let absolute_or_empty = 1
    3              0.000001   endif
    3              0.000006   let detected.path = absolute_or_empty ? detected.bufname : ''
    3              0.000019   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
    3              0.000005   if len(pre) && exists('*' . pre . 'Real')
                                let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
    3              0.000001   endif
                            
    3              0.000002   try
    3              0.000009     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
                                  let detected.path = ''
    3              0.000001     endif
                              catch
    3              0.000002   endtry
    3   0.008459   0.000021   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
    3   0.000205   0.000025   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
    3   0.000235   0.000029   call extend(detected.declared, s:ModelineOptions())
    3              0.000001   return detected

FUNCTION  <SNR>39_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:206
Called 35 times
Total time:   0.000537
 Self time:   0.000537

count  total (s)   self (s)
   35              0.000102   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
   35              0.000014   endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/ftplugin.vim:15
Called 11 times
Total time:   0.033352
 Self time:   0.024236

count  total (s)   self (s)
   11              0.000038     if exists("b:undo_ftplugin")
    1              0.000010       exe b:undo_ftplugin
    1              0.000001       unlet! b:undo_ftplugin b:did_ftplugin
   11              0.000007     endif
                            
   11              0.000040     let s = expand("<amatch>")
   11              0.000015     if s != ""
   11              0.000060       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   11              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   22              0.000052       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   11   0.032989   0.023872         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   22              0.000024       endfor
   11              0.000004     endif

FUNCTION  <SNR>26_FnmatchReplace()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:207
Called 9 times
Total time:   0.000224
 Self time:   0.000140

count  total (s)   self (s)
    9              0.000011   if has_key(s:fnmatch_replacements, a:pat)
    7              0.000006     return s:fnmatch_replacements[a:pat]
    2              0.000002   elseif len(a:pat) ==# 1
                                return '\' . a:pat
    2              0.000006   elseif a:pat =~# '^{[+-]\=\d\+\.\.[+-]\=\d\+}$'
                                return '\%(' . join(range(matchstr(a:pat, '[+-]\=\d\+'), matchstr(a:pat, '\.\.\zs[+-]\=\d\+')), '\|') . '\)'
    2              0.000029   elseif a:pat =~# '^{.*\\\@<!\%(\\\\\)*,.*}$'
    2              0.000001     let done = []
    2              0.000002     let rest = a:pat[0:-2]
   10              0.000007     while !empty(rest)
    8              0.000026       let match = matchstr(rest, '\%(\\.\|{[^\{}]*}\|[^,]\)*', 1)
    8              0.000011       let rest = strpart(rest, len(match) + 1)
    8   0.000099   0.000014       call add(done, s:FnmatchTranslate(match))
   10              0.000003     endwhile
    2              0.000004     return '\%(' . join(done, '\|') . '\)'
                              elseif a:pat =~# '^{.*}$'
                                return '{' . s:FnmatchTranslate(a:pat[1:-2]) . '}'
                              elseif a:pat =~# '^\[!'
                                return '[^' . a:pat[2:-1]
                              else
                                return a:pat
                              endif

FUNCTION  <SNR>26_UserOptions()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:460
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000004   if exists('b:sleuth_' . a:name)
                                let source = 'b:sleuth_' . a:name
    3              0.000005   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
                                let source = 'g:sleuth_' . a:ft . '_' . a:name
    3              0.000001   endif
    3              0.000006   if !exists('l:source') || type(eval(source)) == type(function('tr'))
    3              0.000001     return {}
                              endif
                              let val = eval(source)
                              let options = {}
                              if type(val) == type('')
                                call s:ParseOptions(split(substitute(val, '\S\@<![=+]\S\@=', 'ft=', 'g'), '[[:space:]:,]\+'), options, source)
                                if has_key(options, 'filetype')
                                  call extend(options, s:UserOptions(remove(options, 'filetype')[0], a:name), 'keep')
                                endif
                                if has_key(options, 'tabstop')
                                  call extend(options, {'shiftwidth': [0, source], 'expandtab': [0, source]}, 'keep')
                                elseif has_key(options, 'shiftwidth')
                                  call extend(options, {'expandtab': [1, source]}, 'keep')
                                endif
                              elseif type(val) == type([])
                                call s:ParseOptions(val, options, source)
                              endif
                              call filter(options, 'index(s:safe_options, v:key) >= 0')
                              return options

FUNCTION  <SNR>26_ModelineOptions()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:182
Called 3 times
Total time:   0.000206
 Self time:   0.000150

count  total (s)   self (s)
    3              0.000002   let options = {}
    3              0.000008   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
                                return options
    3              0.000001   endif
    3              0.000006   let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
    3              0.000004   if line('$') > 2 * modelines
                                let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
    3              0.000001   else
    3              0.000004     let lnums = range(1, line('$'))
    3              0.000001   endif
    9              0.000004   for lnum in lnums
    6   0.000151   0.000096     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
                                  break
    6              0.000001     endif
    9              0.000002   endfor
    3              0.000001   return options

FUNCTION  <SNR>42_GetManifestPath()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/rplugin.vim:7
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000000   let manifest_base = ''
                            
    1              0.000001   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
    1              0.000000   endif
                            
    1              0.000001   let dest = stdpath('data')
    1              0.000001   if !empty(dest)
    1              0.000006     if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
    1              0.000000     endif
    1              0.000001     let manifest_base = dest
    1              0.000000   endif
                            
    1              0.000001   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>26_FnmatchTranslate()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:232
Called 12 times
Total time:   0.000507
 Self time:   0.000292

count  total (s)   self (s)
   12   0.000361   0.000344   return substitute(a:pat, '\\.\|/\*\*/\*\=\|\*\*\=\|\[[!^]\=\]\=[^]/]*\]\|{\%(\\.\|[^{}]\|{[^\{}]*}\)*}\|[?.\~^$[]', '\=s:FnmatchReplace(submatch(0))', 'g')

FUNCTION  <SNR>26_Apply()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:396
Called 4 times
Total time:   0.000485
 Self time:   0.000483

count  total (s)   self (s)
    4              0.000012   let options = extend(copy(a:detected.defaults), a:detected.options)
    4              0.000010   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
                                let options.tabstop = options.shiftwidth
                                let options.shiftwidth = a:detected.defaults.shiftwidth
    4              0.000001   endif
    4              0.000005   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
                                let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
    4              0.000001   endif
    4              0.000006   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
                                let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
    4              0.000001   endif
    4              0.000002   let msg = ''
    4              0.000002   let cmd = 'setlocal'
   39              0.000016   for option in a:permitted_options
   35              0.000066     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
   15              0.000004       continue
   20              0.000003     endif
   20              0.000014     let value = options[option]
   20              0.000014     if has_key(s:booleans, option)
   10              0.000010       let setting = (value[0] ? '' : 'no') . option
   10              0.000002     else
   10              0.000010       let setting = option . '=' . value[0]
   20              0.000003     endif
   20              0.000037     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
   12              0.000011       let cmd .= ' ' . setting
   20              0.000003     endif
   20              0.000008     if !&verbose || a:silent
   20              0.000020       if has_key(s:booleans, option)
   10              0.000017         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
   10              0.000002       else
   10              0.000017         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
   20              0.000004       endif
   20              0.000005       continue
                                endif
                                if len(value) > 1
                                  if value[1] ==# a:detected.bufname
                                    let file = '%'
                                  else
                                    let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
                                    if file !=# value[1] && file[0:0] !=# '~'
                                      let file = './' . file
                                    endif
                                  endif
                                  if len(value) > 2
                                    let file .= ' line ' . value[2]
                                  endif
                                  echo printf(':setlocal %-21s " from %s', setting, file)
                                else
                                  echo ':setlocal ' . setting
                                endif
    4              0.000004   endfor
    4              0.000004   if !&verbose && !empty(msg) && !a:silent
                                echo ':setlocal' . msg
    4              0.000001   endif
    4              0.000003   if has_key(options, 'shiftwidth')
    3              0.000006     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
    1              0.000000   else
    1   0.000006   0.000003     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
    4              0.000001   endif
    4              0.000004   return cmd ==# 'setlocal' ? '' : cmd

FUNCTION  <SNR>26_DetectEditorConfig()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:270
Called 3 times
Total time:   0.008438
 Self time:   0.000535

count  total (s)   self (s)
    3              0.000004   if empty(a:absolute_path)
                                return [{}, '']
    3              0.000001   endif
    3              0.000002   let root = ''
    3              0.000003   let tail = a:0 ? a:1 : '.editorconfig'
    3              0.000005   let dir = fnamemodify(a:absolute_path, ':h')
    3              0.000002   let previous_dir = ''
    3              0.000002   let sections = []
    3              0.000005   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
   13              0.000037   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
   12              0.000040     let head = substitute(dir, '/\=$', '/', '')
   12              0.000030     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
   12              0.000007     if read_from is# ''
                                  break
   12              0.000024     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
                                  let read_from = simplify(head . read_from)
   12              0.000002     endif
   12              0.000059     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
   12              0.000030     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
   12              0.000008     if ftime != cachetime
    1   0.007916   0.000013       let econfig = s:ReadEditorConfig(read_from)
    1              0.000002       let s:editorconfig_cache[read_from] = [ftime] + econfig
    1              0.000005       lockvar! s:editorconfig_cache[read_from]
    1              0.000001       unlockvar s:editorconfig_cache[read_from]
   12              0.000002     endif
   12              0.000019     call extend(sections, econfig[1], 'keep')
   12              0.000017     if get(econfig[0], 'root', [''])[0] ==? 'true'
    2              0.000001       let root = head
    2              0.000001       break
   10              0.000003     endif
   10              0.000007     let previous_dir = dir
   10              0.000010     let dir = fnamemodify(dir, ':h')
   13              0.000034   endwhile
                            
    3              0.000002   let config = {}
   11              0.000008   for [pattern, pairs] in sections
    8              0.000036     if a:absolute_path =~# pattern
    2              0.000007       call extend(config, pairs)
    8              0.000001     endif
   11              0.000015   endfor
                            
    3              0.000002   return [config, root]

FUNCTION  <SNR>26_ReadEditorConfig()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:236
Called 1 time
Total time:   0.007903
 Self time:   0.007481

count  total (s)   self (s)
    1              0.000000   try
    1              0.000276     let lines = readfile(a:absolute_path)
                              catch
                                let lines = []
    1              0.000000   endtry
    1              0.000003   let prefix = '\m\C^' . escape(fnamemodify(a:absolute_path, ':h'), '][^$.*\~')
    1              0.000001   let preamble = {}
    1              0.000001   let pairs = preamble
    1              0.000001   let sections = []
    1              0.000001   let i = 0
  164              0.000103   while i < len(lines)
  163              0.000106     let line = lines[i]
  163              0.000066     let i += 1
  163              0.001823     let line = substitute(line, '^[[:space:]]*\|[[:space:]]*\%([^[:space:]]\@<![;#].*\)\=$', '', 'g')
  163              0.002974     let match = matchlist(line, '^\%(\[\(\%(\\.\|[^\;#]\)*\)\]\|\([^[:space:]]\@=[^;#=:]*[^;#=:[:space:]]\)[[:space:]]*[=:][[:space:]]*\(.*\)\)$')
  163              0.000144     if len(get(match, 2, ''))
  128              0.000248       let pairs[tolower(match[2])] = [match[3], a:absolute_path, i]
   35              0.000046     elseif len(get(match, 1, '')) && len(get(match, 1, '')) <= 4096
    4              0.000005       if match[1] =~# '^/'
                                    let pattern = match[1]
    4              0.000004       elseif match[1] =~# '/'
                                    let pattern = '/' . match[1]
    4              0.000001       else
    4              0.000004         let pattern = '/**/' . match[1]
    4              0.000001       endif
    4              0.000002       let pairs = {}
    4   0.000454   0.000032       call add(sections, [prefix . s:FnmatchTranslate(pattern) . '$', pairs])
  163              0.000028     endif
  164              0.000819   endwhile
    1              0.000001   return [preamble, sections]

FUNCTION  <SNR>26_EditorConfigToOptions()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:329
Called 3 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
    3              0.000002   let options = {}
    3              0.000016   let pairs = map(copy(a:pairs), 'v:val[0]')
    3              0.000011   let sources = map(copy(a:pairs), 'v:val[1:-1]')
    3              0.000010   call filter(pairs, 'v:val !=? "unset"')
                            
    3              0.000003   if get(pairs, 'indent_style', '') ==? 'tab'
                                let options.expandtab = [0] + sources.indent_style
    3              0.000003   elseif get(pairs, 'indent_style', '') ==? 'space'
    2              0.000003     let options.expandtab = [1] + sources.indent_style
    3              0.000001   endif
                            
    3              0.000010   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
    2              0.000004     let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
    2              0.000004     if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = [0] + sources.indent_size
    2              0.000001     endif
    3              0.000001   endif
                            
    3              0.000008   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
    2              0.000003     let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
    2              0.000003     if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
                                  let options.shiftwidth = [0] + options.tabstop[1:-1]
    2              0.000000     endif
    3              0.000001   endif
                            
    3              0.000007   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
                                let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
    3              0.000001   endif
                            
    3              0.000008   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
    2              0.000003     let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
    2              0.000003     let options.fixendofline = copy(options.endofline)
    3              0.000001   endif
                            
    3              0.000004   let eol = tolower(get(pairs, 'end_of_line', ''))
    3              0.000004   if has_key(s:editorconfig_fileformat, eol)
    2              0.000004     let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
    3              0.000001   endif
                            
    3              0.000004   let charset = tolower(get(pairs, 'charset', ''))
    3              0.000003   if has_key(s:editorconfig_bomb, charset)
    2              0.000003     let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
    2              0.000006     let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
    3              0.000001   endif
                            
    3              0.000004   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
    3              0.000003   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
                                let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
    3              0.000001   endif
                            
    3              0.000001   return options

FUNCTION  <SNR>26_Guess()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:38
Called 1 time
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000005   let has_heredocs = a:detected.filetype =~# '^\%(perl\|php\|ruby\|[cz]\=sh\|bash\)$'
    1              0.000001   let options = {}
    1              0.000002   let heuristics = {'spaces': 0, 'hard': 0, 'soft': 0, 'checked': 0, 'indents': {}}
    1              0.000002   let tabstop = get(a:detected.options, 'tabstop', get(a:detected.defaults, 'tabstop', [8]))[0]
    1              0.000001   let softtab = repeat(' ', tabstop)
    1              0.000001   let waiting_on = ''
    1              0.000001   let prev_indent = -1
    1              0.000001   let prev_line = ''
                            
    2              0.000001   for line in a:lines
    1              0.000001     if len(waiting_on)
                                  if line =~# waiting_on
                                    let waiting_on = ''
                                    let prev_indent = -1
                                    let prev_line = ''
                                  endif
                                  continue
    1              0.000002     elseif line =~# '^\s*$'
    1              0.000000       continue
                                elseif a:detected.filetype ==# 'python' && prev_line[-1:-1] =~# '[[\({]'
                                  let prev_indent = -1
                                  let prev_line = ''
                                  continue
                                elseif line =~# '^=\w' && line !~# '^=\%(end\|cut\)\>'
                                  let waiting_on = '^=\%(end\|cut\)\>'
                                elseif line =~# '^@@\+ -\d\+,\d\+ '
                                  let waiting_on = '^$'
                                elseif line !~# '[/<"`]'
                                  " No need to do other checks
                                elseif line =~# '^\s*/\*' && line !~# '\*/'
                                  let waiting_on = '\*/'
                                elseif line =~# '^\s*<\!--' && line !~# '-->'
                                  let waiting_on = '-->'
                                elseif line =~# '^[^"]*"""'
                                  let waiting_on = '^[^"]*"""'
                                elseif a:detected.filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                  let waiting_on = '^[^`]*`[^`]*$'
                                elseif has_heredocs
                                  let waiting_on = matchstr(line, '<<\s*\([''"]\=\)\zs\w\+\ze\1[^''"`<>]*$')
                                  if len(waiting_on)
                                    let waiting_on = '^' . waiting_on . '$'
                                  endif
                                endif
                            
                                let indent = len(matchstr(substitute(line, '\t', softtab, 'g'), '^ *'))
                                if line =~# '^\t'
                                  let heuristics.hard += 1
                                elseif line =~# '^' . softtab
                                  let heuristics.soft += 1
                                endif
                                if line =~# '^  '
                                  let heuristics.spaces += 1
                                endif
                                let increment = prev_indent < 0 ? 0 : indent - prev_indent
                                let prev_indent = indent
                                let prev_line = line
                                if increment > 1 && (increment < 4 || increment % 4 == 0)
                                  if has_key(heuristics.indents, increment)
                                    let heuristics.indents[increment] += 1
                                  else
                                    let heuristics.indents[increment] = 1
                                  endif
                                  let heuristics.checked += 1
                                endif
                                if heuristics.checked >= 32 && (heuristics.hard > 3 || heuristics.soft > 3) && get(heuristics.indents, increment) * 2 > heuristics.checked
                                  if heuristics.spaces
                                    break
                                  elseif !exists('no_space_indent')
                                    let no_space_indent = stridx("\n" . join(a:lines, "\n"), "\n  ") < 0
                                    if no_space_indent
                                      break
                                    endif
                                  endif
                                  break
                                endif
    1              0.000002   endfor
                            
    1              0.000002   let a:detected.heuristics[a:source] = heuristics
                            
    1              0.000001   let max_frequency = 0
    1              0.000001   for [shiftwidth, frequency] in items(heuristics.indents)
                                if frequency > max_frequency || frequency == max_frequency && +shiftwidth < get(options, 'shiftwidth')
                                  let options.shiftwidth = +shiftwidth
                                  let max_frequency = frequency
                                endif
    1              0.000000   endfor
                            
    1              0.000001   if heuristics.hard && !heuristics.spaces && !has_key(a:detected.options, 'tabstop')
                                let options = {'expandtab': 0, 'shiftwidth': 0}
    1              0.000001   elseif heuristics.hard > heuristics.soft
                                let options.expandtab = 0
                                let options.tabstop = tabstop
    1              0.000000   else
    1              0.000000     if heuristics.soft
                                  let options.expandtab = 1
    1              0.000000     endif
    1              0.000003     if heuristics.hard || has_key(a:detected.options, 'tabstop') || stridx(join(a:lines, "\n"), "\t") >= 0
                                  let options.tabstop = tabstop
    1              0.000002     elseif !&g:shiftwidth && has_key(options, 'shiftwidth') && !has_key(a:detected.options, 'shiftwidth')
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = 0
    1              0.000000     endif
    1              0.000000   endif
                            
    1              0.000001   call map(options, '[v:val, a:source]')
    1              0.000002   call extend(a:detected.options, options, 'keep')

FUNCTION  <SNR>26_Init()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:593
Called 4 times
Total time:   0.009957
 Self time:   0.000172

count  total (s)   self (s)
    4              0.000006   if !a:redetect && exists('b:sleuth.defaults')
    1              0.000001     let detected = b:sleuth
    4              0.000001   endif
    4              0.000010   unlet! b:sleuth
    4              0.000020   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
                                return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
    4              0.000001   endif
    4              0.000004   if &l:filetype ==# 'netrw'
                                return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
    4              0.000001   endif
    4              0.000002   if &l:binary
                                return s:Warn(':Sleuth disabled for binary files', a:silent)
    4              0.000001   endif
    4              0.000004   if !exists('detected')
    3   0.009039   0.000012     let detected = s:DetectDeclared()
    4              0.000001   endif
    4              0.000003   let setfiletype = ''
    4              0.000005   if a:do_filetype && has_key(detected.declared, 'filetype')
                                let filetype = detected.declared.filetype[0]
                                if filetype !=# &l:filetype || empty(filetype)
                                  let setfiletype = 'setlocal filetype=' . filetype
                                else
                                  let setfiletype = 'setfiletype ' . filetype
                                endif
    4              0.000001   endif
    4              0.000004   exe setfiletype
    4   0.000287   0.000015   call s:DetectHeuristics(detected)
    4   0.000509   0.000024   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
    4              0.000003   let b:sleuth = detected
    4              0.000003   if exists('s:polyglot') && !a:silent
                                call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
                                call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
                                call s:Warn('corresponding feature in your vimrc:')
                                call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
    4              0.000001   endif
    4              0.000002   return cmd

FUNCTION  <SNR>26_AutoInit()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:632
Called 3 times
Total time:   0.009833
 Self time:   0.000014

count  total (s)   self (s)
    3   0.009832   0.000012   return s:Init(1, 1, 1, 1)

FUNCTION  <SNR>26_Warn()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:19
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if !get(a:000, 0, 0)
                                echohl WarningMsg
                                echo a:msg
                                echohl NONE
    1              0.000000   endif
    1              0.000000   return ''

FUNCTION  <SNR>26_DetectHeuristics()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:513
Called 4 times
Total time:   0.000272
 Self time:   0.000161

count  total (s)   self (s)
    4              0.000003   let detected = a:into
    4              0.000008   let filetype = split(&l:filetype, '\.', 1)[0]
    4              0.000005   if get(detected, 'filetype', '*') ==# filetype
    1              0.000000     return detected
    3              0.000001   endif
    3              0.000002   let detected.filetype = filetype
    3              0.000004   let options = copy(detected.declared)
    3              0.000002   let detected.options = options
    3              0.000002   let detected.heuristics = {}
    3              0.000002   if has_key(detected, 'patterns')
                                call remove(detected, 'patterns')
    3              0.000000   endif
    3   0.000033   0.000010   let detected.defaults = s:UserOptions(filetype, 'defaults')
    3              0.000013   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
                                return detected
    3              0.000001   endif
    3   0.000013   0.000006   if s:Ready(detected)
    2              0.000001     return detected
    1              0.000000   endif
                            
    1              0.000001   let lines = getline(1, 1024)
    1   0.000083   0.000004   call s:Guess(detected.bufname, detected, lines)
    1   0.000004   0.000002   if s:Ready(detected)
                                return detected
    1              0.000002   elseif get(options, 'shiftwidth', [4])[0] < 4 && stridx(join(lines, "\n"), "\t") == -1
                                let options.expandtab = [1, detected.bufname]
                                return detected
    1              0.000000   endif
    1              0.000002   let dir = len(detected.path) ? fnamemodify(detected.path, ':h') : ''
    1   0.000045   0.000044   let root = len(detected.root) ? fnamemodify(detected.root, ':h') : dir ==# s:Slash(expand('~')) ? dir : fnamemodify(dir, ':h')
    1              0.000003   if detected.bufname =~# '^\a\a\+:' || root ==# '.' || !isdirectory(root)
    1              0.000001     let dir = ''
    1              0.000000   endif
    1              0.000002   let c = get(b:, 'sleuth_neighbor_limit', get(g:, 'sleuth_neighbor_limit', 8))
    1              0.000001   if c <= 0 || empty(dir)
    1              0.000001     let detected.patterns = []
                              elseif type(get(b:, 'sleuth_globs')) == type([])
                                let detected.patterns = b:sleuth_globs
                              elseif type(get(g:, 'sleuth_' . detected.filetype . '_globs')) == type([])
                                let detected.patterns = get(g:, 'sleuth_' . detected.filetype . '_globs')
                              else
                                let detected.patterns = ['*' . matchstr(detected.bufname, '/\@<!\.[^][{}*?$~\`./]\+$')]
                                if detected.patterns ==# ['*']
                                  let detected.patterns = [matchstr(detected.bufname, '/\zs[^][{}*?$~\`/]\+\ze/\=$')]
                                  let dir = fnamemodify(dir, ':h')
                                  if empty(detected.patterns[0])
                                    let detected.patterns = []
                                  endif
                                endif
    1              0.000000   endif
    1              0.000003   while c > 0 && dir !~# '^$\|^//[^/]*$' && dir !=# fnamemodify(dir, ':h')
                                for pattern in detected.patterns
                                  for neighbor in split(glob(dir.'/'.pattern), "\n")[0:7]
                                    if neighbor !=# detected.path && filereadable(neighbor)
                                      call s:Guess(neighbor, detected, readfile(neighbor, '', 256))
                                      let c -= 1
                                    endif
                                    if s:Ready(detected)
                                      return detected
                                    endif
                                    if c <= 0
                                      break
                                    endif
                                  endfor
                                  if c <= 0
                                    break
                                  endif
                                endfor
                                if len(dir) <= len(root)
                                  break
                                endif
                                let dir = fnamemodify(dir, ':h')
    1              0.000001   endwhile
    1              0.000001   if !has_key(options, 'shiftwidth')
    1              0.000001     let detected.options = copy(detected.declared)
    1              0.000000   endif
    1              0.000000   return detected

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/indent.vim:14
Called 11 times
Total time:   0.007416
 Self time:   0.007144

count  total (s)   self (s)
   11              0.000020     if exists("b:undo_indent")
    1              0.000004       exe b:undo_indent
    1              0.000001       unlet! b:undo_indent b:did_indent
   11              0.000003     endif
   11              0.000021     let s = expand("<amatch>")
   11              0.000009     if s != ""
   11              0.000010       if exists("b:did_indent")
                            	unlet b:did_indent
   11              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   22              0.000032       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   11   0.007231   0.006960         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   22              0.000013       endfor
   11              0.000004     endif

FUNCTION  MatchEnable()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim:49
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000003   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
    1              0.000002   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
    1              0.000003   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
    1              0.000002   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
    1              0.000002   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
    1              0.000002   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
                              " Analogues of [{ and ]} using matching patterns:
    1              0.000002   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
    1              0.000002   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
    1              0.000002   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
    1              0.000002   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
    1              0.000002   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
    1              0.000002   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
                              " text object:
    1              0.000003   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
                            
    1              0.000001   if !exists("g:no_plugin_maps")
    1              0.000001     nmap <silent> %  <Plug>(MatchitNormalForward)
    1              0.000001     nmap <silent> g% <Plug>(MatchitNormalBackward)
    1              0.000001     xmap <silent> %  <Plug>(MatchitVisualForward)
    1              0.000001     xmap <silent> g% <Plug>(MatchitVisualBackward)
    1              0.000001     omap <silent> %  <Plug>(MatchitOperationForward)
    1              0.000001     omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                                " Analogues of [{ and ]} using matching patterns:
    1              0.000001     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
    1              0.000001     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
    1              0.000001     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
    1              0.000001     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
    1              0.000001     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
    1              0.000001     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                                " Text object
    1              0.000001     xmap a% <Plug>(MatchitVisualTextObject)
    1              0.000000   endif

FUNCTION  <SNR>42_GetManifest()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/rplugin.vim:44
Called 1 time
Total time:   0.000053
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000018   0.000002   let manifest = s:GetManifestPath()
    1              0.000002   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
    2   0.000014   0.000004     for old_manifest in s:GetOldManifestPaths()
    1              0.000002       if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
    1              0.000000       endif
    2              0.000013     endfor
    1              0.000000   endif
    1              0.000000   return manifest

FUNCTION  <SNR>26_Ready()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:384
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000007   return has_key(a:detected.options, 'expandtab') && has_key(a:detected.options, 'shiftwidth')

FUNCTION  <SNR>53_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/synload.vim:27
Called 18 times
Total time:   0.018251
 Self time:   0.017153

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   18              0.000051   syn clear
   18              0.000024   if exists("b:current_syntax")
                                unlet b:current_syntax
   18              0.000006   endif
                            
   18              0.000033   0verbose let s = expand("<amatch>")
   18              0.000014   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   18              0.000013   elseif s == "OFF"
                                let s = ""
   18              0.000004   endif
                            
   18              0.000009   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   22              0.000036     for name in split(s, '\.')
   11              0.000012       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   11   0.017852   0.016754         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   11              0.000007       endif
   22              0.000012     endfor
   18              0.000004   endif

FUNCTION  <SNR>12_Map()
    Defined: ~/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim:730
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000004   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
    2              0.000001   let head = a:lhs
    2              0.000001   let tail = ''
    2              0.000002   let keys = get(g:, a:mode.'remap', {})
    2              0.000002   if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
    2              0.000000   endif
    2              0.000008   if empty(mapcheck(head.tail, a:mode))
    2              0.000006     exe a:mode.'map' flags head.tail a:rhs
    2              0.000000   endif

FUNCTION  <SNR>26_Slash()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:33
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    4              0.000004     return a:path

FUNCTION  <SNR>42_LoadRemotePlugins()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/rplugin.vim:58
Called 1 time
Total time:   0.000059
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000056   0.000004   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000002   if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000000   endif

FUNCTION  <SNR>39_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:44
Called 33 times
Total time:   0.003352
 Self time:   0.002871

count  total (s)   self (s)
   33              0.000188   if !exists("w:matchparen_ids")
    1              0.000001     let w:matchparen_ids = []
   33              0.000040   endif
                              " Remove any previous match.
   33   0.000692   0.000212   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   33              0.000124   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   33              0.000011   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   33              0.000096   let c_lnum = line('.')
   33              0.000069   let c_col = col('.')
   33              0.000026   let before = 0
                            
   33              0.000085   let text = getline(c_lnum)
   33              0.000588   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   33              0.000069   if empty(matches)
                                let [c_before, c] = ['', '']
   33              0.000020   else
   33              0.000114     let [c_before, c] = matches[1:2]
   33              0.000013   endif
   33              0.000424   let plist = split(&matchpairs, '.\zs[:,]')
   33              0.000124   let i = index(plist, c)
   33              0.000030   if i < 0
                                " not found, in Insert mode try character before the cursor
   33              0.000076     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   33              0.000013     endif
   33              0.000021     if i < 0
                                  " not found, nothing to do
   33              0.000036       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>42_GetOldManifestPaths()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/rplugin.vim:28
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
    1              0.000006   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
    1              0.000001   if !has('win32')
    1              0.000000     return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]

FUNCTION  <SNR>26_ParseOptions()
    Defined: ~/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim:166
Called 6 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    6              0.000005   for option in a:declarations
                                if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
                                  let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
                                elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
                                  let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
                                elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
                                  let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
                                endif
                                if option ==# 'nomodeline' || option ==# 'noml'
                                  return 1
                                endif
    6              0.000003   endfor
    6              0.000002   return 0

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   11   0.033352   0.024236  <SNR>1_LoadFTPlugin()
   18   0.018251   0.017153  <SNR>53_SynSet()
    4   0.009957   0.000172  <SNR>26_Init()
    3   0.009833   0.000014  <SNR>26_AutoInit()
    3   0.009028   0.000199  <SNR>26_DetectDeclared()
    3   0.008438   0.000535  <SNR>26_DetectEditorConfig()
    1   0.007903   0.007481  <SNR>26_ReadEditorConfig()
   11   0.007416   0.007144  <SNR>2_LoadIndent()
   33   0.003352   0.002871  <SNR>39_Highlight_Matching_Pair()
   35   0.000537             <SNR>39_Remove_Matches()
   12   0.000507   0.000292  <SNR>26_FnmatchTranslate()
    4   0.000485   0.000483  <SNR>26_Apply()
    4   0.000272   0.000161  <SNR>26_DetectHeuristics()
    9   0.000224   0.000140  <SNR>26_FnmatchReplace()
    3   0.000206   0.000150  <SNR>26_ModelineOptions()
    3   0.000180             <SNR>26_EditorConfigToOptions()
    1   0.000079             <SNR>26_Guess()
    1   0.000059   0.000006  <SNR>42_LoadRemotePlugins()
    6   0.000056             <SNR>26_ParseOptions()
    1   0.000053   0.000027  <SNR>42_GetManifest()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   11   0.033352   0.024236  <SNR>1_LoadFTPlugin()
   18   0.018251   0.017153  <SNR>53_SynSet()
    1   0.007903   0.007481  <SNR>26_ReadEditorConfig()
   11   0.007416   0.007144  <SNR>2_LoadIndent()
   33   0.003352   0.002871  <SNR>39_Highlight_Matching_Pair()
   35              0.000537  <SNR>39_Remove_Matches()
    3   0.008438   0.000535  <SNR>26_DetectEditorConfig()
    4   0.000485   0.000483  <SNR>26_Apply()
   12   0.000507   0.000292  <SNR>26_FnmatchTranslate()
    3   0.009028   0.000199  <SNR>26_DetectDeclared()
    3              0.000180  <SNR>26_EditorConfigToOptions()
    4   0.009957   0.000172  <SNR>26_Init()
    4   0.000272   0.000161  <SNR>26_DetectHeuristics()
    3   0.000206   0.000150  <SNR>26_ModelineOptions()
    9   0.000224   0.000140  <SNR>26_FnmatchReplace()
    1              0.000079  <SNR>26_Guess()
    6              0.000056  <SNR>26_ParseOptions()
    1              0.000045  MatchEnable()
    2              0.000034  <SNR>12_Map()
    1   0.000053   0.000027  <SNR>42_GetManifest()

